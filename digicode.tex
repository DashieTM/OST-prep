\documentclass{article}
\usepackage[left=-1.5mm, right=-1.5mm, top=-1mm, bottom=-1.5mm]{geometry}
\usepackage[document]{ragged2e}
\usepackage{graphicx}
\usepackage{amsmath, mathtools, nccmath, amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage{array, makecell}
\usepackage[T1]{fontenc}
\usepackage{noto-sans}
\renewcommand\cellalign{cl}
\renewcommand\theadalign{lc}
\newcommand{\ns}{\\ \vspace{-0.03in}}
\newcommand{\mc}[1]{\makecell[cl]{\vspace{-0.065in} \\ #1}}
\newcommand{\mcc}{\makecell[{{c}}]}
\newcommand{\mcr}{\makecell[{{r}}]}
\newcommand{\pic}{\includegraphics[scale=0.3]}
\newcommand{\form}[1]{\vspace{-0.03in}\\ \small{\textcolor{Red}{\(#1\)}} \\ \vspace{-0.03in}}
\newcommand{\noskipform}[1]{\small{\textcolor{Red}{\(#1\)}}}
\newcommand{\fpic}{\vspace{-0.05in} \\ \includegraphics[scale=0.3]}
\renewcommand{\b}{\textbf}
\renewcommand{\r}[1]{\textcolor{Red}{#1}}
%\renewcommand{\arraystretch}{1.5}
\graphicspath{{/home/dashie/Templates/Screenshots/}}
\begin{document}
    \begin{table}[ht!]
        \begin{tiny}
          \begin{tabular}{ccc}
          \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\b{Number Base Case} \\ \(N= d_n R^n + d_1 R^1 + d_0 R^0 \) \\ the d specifies the Number system -> \(d_2\) == binary \\ 
              can also be written as \(R_2\) \\ 
              This can also be used to expand numbers: \\ \(N_{10} 255 = 2 * 10^2 + 5 * 10^1 + 5 * 10^0 \) \\ \(N_2 110 = 1 * 2^2 + 1 * 2^1 + 0 * 2^0 => N_{10} 6\)}\\
              \hline
              \mc{\b{Quantities:} \\ \b{N} -> natural numbers  | |  \b{Z} -> full numbers \\  \b{Q} -> rational numbers | | \b{R} -> real numbers}\\
              \hline
              \mc{\b{Common number systems:} \\ Decimal: \(N_{10} = n * 10^n .. 0 * 10^0\) \\ \b{Binary:} \(N_2 = n * 2^n .. 0 * 2^0\) \\
                \(2^{10}=1024, 2^9=512, 2^8=256, 2^7=128, 2^6=64,\) \\  \(2^5=32, 2^4=16,2^3=8, 2^2=4, 2^1=2, 2^0=1\) \\ \b{Hexadecimal:} \(N_16 = n * n^{16} .. 0 * 16^0\) \\ 
              notation: 0 1 2 3 4 5 6 7 8 9 A B C D E F \\ \(16^5=1048576, 16^4=65536, 16^3=4096, 16^2=256,\) \\  \(16^1=16, 16^0=1\) }\\
              \hline
              \mc{\b{Modulo} \\ 8 mod 4 = (8) -> 0 , 8 mod 3 = (6) -> 2 , 8 mod 5 = (5) -> 3 \\ if x<y in x mod y then the result will always be x! \\ 
              any negative numbers can be considered as NOTnegative\\ aka only absolute values! modulo deals with |x| \\ many programming languages actually do not follow this! \\
              they have their own implementation of modulo. \\ 5 \(\equiv\) 3 mod 2 -> as 5 mod 2 = 1 and 3 mod 2 = 1 }\\
              \hline
              \mc{\b{Codeword length} \\ \b{Byte = 8 bit} || \b{Word = 16 or 32 bit} \\ TCP packet = 1024 bit }\\
              \hline
              \mc{ \b{Cyclic group} \\ \pic{220610-19} \\ \pic{220610-18}} \\ WHAT THE FUCK \\
              \hline
              \mc{\b{Result Quantity} the result of all possible outcomes \\ it is denoted with: \(\Omega\) \\ A single element of the result list is: \(\omega\)  -> \(\omega \in  \Omega \) \\ 
              The list of results is \(|\Omega|\) \\ Example Dice roll: \(\Omega = \{1,2,3,4,5,6\}\) }\\
              \hline
              \mc{\small{Probability: \textcolor{Red}{\(P(A) = \dfrac{\text{best results}}{\text{all results}}= \dfrac{|A|}{|\Omega|} = \dfrac{|A|}{n}\)}} \\
              So what is the probability of rolling a 6? \\ 
              \(P(\text{desired number to roll}) = \dfrac{\text{only 1 good result!}}{\text{6 possible results}} = \dfrac{1}{6}\) \\ hence the chance is 1 in 6 \\ Why this complicated method?
              You can modify desired results! \\ just change the A in P(A)!}\\
              \hline
              \mc{\b{Inverse Probability: P(inverse) = 1 - P(A)} \\ dice -> \(1 - \dfrac{1}{6} = \dfrac{5}{6}\) \ns }\\
              \hline
              \mc{\b{Addition rule:}\\ \form{P(A\cup B) = P(A) + P(B) - P(A\cap B)} \\ !!The last part is needed, as otherwise the number \\ would exceed the possible states!! \\ \vspace{-0.05in}\\
              \r{\(P(A\cup B \cup C) = P(A) + P(B) + P(C) - P(A\cap B) - P(A\cap C)\)} \\ \textcolor{Red}{\(- P(B\cap C) + P(A\cap B\cap C)\)}}\\
              \hline
              \mc{\b{Amount of possibilities:} \\ \b{ordered probes with replication:} \\ 2 coins, head and tail, possibilities? \b{k}=head/tail=2 \b{n}=coins=2 \\ \form{\Omega = n^k = 2^2} \\
              \b{ordered probes without replication:} \\ 5 dices. How many combinations? \\  dice numbers = \b{n} = 6 (1-6), dice amount = \b{k} = 5 
              \\ possibilities = \(\Omega = \dfrac{n!}{(n-k)!} = 
              \Omega = \dfrac{6!}{(6-5)!} = 720\) \\ Or this: \\ \form{\Omega = \Pi^{n-k+1}_{n} n = \Pi^{6-5+1}_{6} 6 = 2*3...5*6 = 720} \\
              \b{unordered probes wihout replication:} \\ 25 players, each should only play once with the other. \\ \(\Omega = \dfrac{n!}{k!(n-k)!}\) -> \(\dfrac{25!}{2!(25-2)!}\) -> 
              \(\dfrac{\text{too big}}{\text{too big}} = 300 \) \\
              as you can see the bottom is a BIG calculation, so \\ \form{ \Omega = \dfrac{\Pi^{n-k+1}_{n}n}{k!} \text{->} \dfrac{\Pi^{25-2+1}_{25}25}{2!}
              \text{->} \dfrac{24*25}{2} = 300 } \\ Note that \b{k} can also be defined as the \\ length of the tuple we want to receive. \\ -> (Player,Player) - > 2}\\
              \hline
              \mc{\b{Source to Sink Information} \\ \pic{220610-20} }\\
              \hline
              \mc{\small{\b{Entropy}} \\ \footnotesize{information content} \\ this essentially just us how many bits are needed \\ 
              \b{k} is base state count -> bit = 2 \\ and \b{N} is the full number of states \\ 
            example: list {True,False,True,False} 4 states total, base 2. \\ \form{H_0 = log_k(N) [k] \text{ -> } H_0 = log_2(4) [bit] = 2} }\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{information flow} \\ essentially information content over time \\ \form{H^*_0 = \dfrac{log_2(N)}{\tau}[\dfrac{bit}{s}]} \\ 
              \footnotesize{information quantity / Surprise} \\ \form{I(x_k) = -log_2(P(x_k))[bit]} \\ 
              \footnotesize{Entropy (Surprise per element)} \\ 0 means no symbols. 1 means perfect balance 50-50 \\ \form{H(X) = \Sigma^N_{k=1} P(x_k) * I(x_k) [\dfrac{bit}{symbol}] } \\ where X is the list of symbols
              \\ \footnotesize{Sink Redundance / Code Reduncance} \\ \begin{tabular}{@{\hskip1pt}m{4cm}m{2cm}}\vspace{-0.15in}\noskipform{R_Q = H_0 - H(X) [\dfrac{bit}{symbol}]}
              \noskipform{R_c = L - H(X) [\dfrac{bit}{symbol}]} & 
              \vspace{-0.25in}\pic{220610-21} \end{tabular} \\ 
              \footnotesize{Code Word Length} \\ \form{L(x_k) = \text{rounded}(I(x_k))[bit]} \\
              \footnotesize{Median Code Word Length} \\ \form{L = \Sigma^N_{k=1}P(x_k) * L(x_k) [\dfrac{bit}{symbol}] } \\ 
              \footnotesize{Entropy of the entire Code} \\ \form{H_c(X) = \Sigma^N_{k=1} P(x_k) * L(x_k) [\dfrac{bit}{symbol}]} \\ \footnotesize{\(H_c\) can be a real number -> \(H_c \in  \mathbb{R} \)}
              }\\
              \hline
              \mc{\fpic{220610-22}}\\
              \hline
              \mc{\footnotesize{Sink without memory} \\ \form{P(x_k,y_k) = P(x_k) + P(y_i)} \\ \footnotesize{Sink with memory} \\ \form{P(x_k,y_i) = P(x_k) + P(x_k|y_i)} \\
              \footnotesize{Entropy without memory / Combined Entropy} \\ \form{H(H,Y) = \Sigma^N_{x_k} \Sigma^N_{y_i} P(x_k,y_i)*(-log_2(P(x_k,y_i))} \\
              or: \(H(X,Y) = H(X) + H(Y) \) \\
              \footnotesize{Entropy with memory} \\ \form{H(H,Y) = \Sigma^N_{x_k} \Sigma^N_{y_i} P(x_k) * }\\ \vspace{-0.1in}\form{P(x_k,y_i)*(-log_2(P(x_k) * P(x_k|y_i))}
              }\\
              \hline
              \mc{\footnotesize{Encoding of Symbols} \\ \pic{220610-23} \\ \pic{220610-24} \\ continue this pattern until every symbol has a code \\ note the extra 0 on every step }\\
              \hline
              \mc{\footnotesize{Run Length Encoding RLE/RLC} \\ \pic{220610-25}}\\
              \hline
              \mc{\b{Encoder and Decoder} \\ You need to either choose 1 or 0 as the starting \\ bit. After that the decoder can print out the correct code.}\\
              \hline
              \mc{\b{Chiffre text} \\ You can "encrypt" your data by \\ shifting the codes by a certain amount. \\ In the caesar chiffre this is done with the number 4. a -> e\\ 
              Please do not use this, use RSA or other algorithms.}\\
              \hline
              \mc{\footnotesize{Errors} \\ \pic{220610-26} \\ \pic{220610-27}}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{Conditional Entropy -> Entropy of Y given X} \\  
              \form{H(Y|X) = \Sigma^N_{k=1} \Sigma^N_{i=1} P(x_k,y_i) * (-log_2(\frac{P(x_k,y_i)}{P(x_k)}))} \\ 
              \footnotesize{Chain Rule} \\ \form{H(Y|X) = H(X,Y) - H(X) \text{ || } H(Y \backslash X)} \\ 
              \footnotesize{Bayes Rule} \\ \form{H(Y|X) = H(X|Y) - H(X) + H(Y) \text{ || } H(Y\backslash X)} \\
              \pic{Entropy} \\
              \footnotesize{Transinformation} \\ likelyhood of information being correct at arrival. \\ 
              \form{T = H(X) - H(X|Y) \text{ || } H(Y) - H(Y|X)} \form{\text{or: }|(X;Y)}
              }\\
              \hline
              \mc{\footnotesize{Hamming distance / distance to next valid codeword} \\ \form{h =Min_{i,j}(d(x_i,x_j)) \text{ -> } h = \text{message points} + 1} \\
                \footnotesize{error detection distance} \\ the amount of bits that differ from input to output \\ 
              \form{e^*=h-1} \\
                \footnotesize{error correction distance for h even} \\ \form{h=2e+2 \text{ -> } e = \dfrac{h - 2}{2}}
                \footnotesize{error correction distance for h uneven} \\ \form{h=2e+1 \text{ -> } e = \dfrac{h - 1}{2}}\\
                  Consider the valid input either 111 or 000. \\  The Hamming distance \b{h} is therefore 3 bits. \\ The detection distance \b{ \( e^* \) } is 3 - 1 \\
                  Due to h being uneven, the correction distance \b{e} is \(\dfrac{h - 1}{2}\) \\ which results in 1.
              }\\
              \hline
              \mc{\footnotesize{tighly packed coderoom} \\ n = dimension of code \vspace{-0.05in}\\ m = dimension of messages \noskipform{2^m * \Sigma^e_{w=0} (^n_w) \leq 2^n}\\
                k = dimension of control -> n = m + k \\ The code is considered to be tightly packed \\ if the equation has the result 2. aka == not smaller. \\ \pic{220611-2}
              }\\
              \hline
              \mc{\footnotesize{Hamming Codes} \\ The hamming code is very easy to implement \\ \form{\Sigma_i x_i * \overrightarrow{\rm P_i} \equiv \overrightarrow{\rm 0} mod 2} \\
              \footnotesize{The syndrome} \noskipform{\overrightarrow{\rm Z} = \Sigma_i x_i * \overrightarrow{\rm P_i} mod 2} \\ 
              \pic{220612-1} \\ \pic{220612-2} \\
              note that the 001 010 100 of the parity checks are \\ simply the unit vector \(\overrightarrow{\rm 0}\) !!!
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{tiny}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{
              \footnotesize{parity checks needed:} \\ \form{par = log_2(\text{bit amount of code})} \\
              \footnotesize{1101 = 4 bits -> 3 parity checks} \\ \footnotesize{as 4 can be displayed by 3 bits -> 100}\\
              \pic{220612-3}
              }\\
              \hline
              \mc{\footnotesize{convolutional code / folding code} \\ \pic{220612-4}\\
              }\\
              \hline
              \mc{\footnotesize{Viterbi algorithm / Decoding convolutional code} \\ \pic{220612-5} \\ \pic{220612-6} \\ \pic{220612-7}}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{Input - Output ratio for convolutional codes} \\ \form{R=\dfrac{input}{output} \text{ in example } R=\dfrac{1}{2}} }\\
              \hline
              \mc{\footnotesize{hamming code extension} \\ \pic{220613-17}}\\
              \hline
              \mc{\pic{220614-1} \\ \pic{220614-2}}\\
              \hline
              \mc{\footnotesize{\r{RSA: !!Check Github for another PDF!!}} \\ 
              }\\
              \hline
              \mc{\footnotesize{RINKEL DONE}}\\
              \hline
              \mc{\r{due to space constraints, something form the last page:}}\\
              \hline
              \mc{\footnotesize{Floating Point Comparison}\\
              Due to the limitation of floating point numbers,\\
              checking for equality the regular way doesn't make sense\\
              \pic{220614-51}\\
              \r{This checks bit pattern!!}\\
              Instead we check if it is approximately equal:\\
              \pic{220614-52}\\
              Problem with this: it's the absolute error\\
              instead we can choose the relative error:\\
              \pic{220614-53}\\
              The Max makes sure the eps is based on the bigger number.\\
              \\
              There are still certain problems: \\ 
              calculations close to 0 might result in the \\ 
              relative error of 1, which is actually not an error \\
              once again rounding errors....\\
              }\\
              \hline
              \mc{\footnotesize{\r{BE AWARE OF FLOATING ERRORS!!}}}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{potence system} \\ decimal binary and hexadecimal are all built the same way \\ 
              \form{W_a(z) = \Sigma^{n-1}_{i=0} z_i * a^i = z_{n-1} * a^{n-1} + }
              \form{z_{n-2} * a^{n-2} + ... + z_1 * a^1 + z_0 * a^0}
              }\\
              \hline
              \mc{\footnotesize{Terms in the binary form}}\\ 
              \hline
              \mc{\scriptsize{Bit = 1} set bit }\\ 
              \hline
              \mc{\scriptsize{Bit = 0} cleared bit} \\
              \hline
              \mc{\scriptsize{LSB} Least Significant Bit, rightmost bit, bit 0}\\
              \hline
              \mc{\scriptsize{MSB} Most Significant Bit, leftmost bit, bit (n-1)}\\
              \mc{\scriptsize{!!Note that this is for little-endian!!} \\ \scriptsize{big-endian is 
              the opposite!!}}\\
              \hline
              \mc{\scriptsize{Nibble} a 4 bit binary number\\ bigger numbers get grouped into nibbles
              -> 1101 0101} \\
              \hline
              \mc{\scriptsize{Octett} a binary number with 8 bit}\\
              \hline
              \mc{\scriptsize{byte} 8 bit}\\
              \hline
              \mc{Note, in binary the leading 0s will still be written, \\ in order to indicate
              how big the memory allocation is.}\\
              \hline
              \mc{\scriptsize{indices in bits} in order to change single bits in a number, \\ 
              we can use the array notation. b=1010 b[3]=1 b=1011}\\
              \hline
              \mc{\scriptsize{amount of numbers to display} \\ binary: \(2^n\) numbers -> n=bits\\
              The amount of numbers to double every increase of potence.\\
              Note: There are no broken binary numbers. It's always \(2^n\) \\ 
              with n being an integer!!
              }\\
              \hline
              \mc{\footnotesize{prefixes} \\ \pic{220613-1} \\ 
                \scriptsize{suffixes: \textcolor{Red}{\(\text{binary:} 1011_b, \text{hex:} 1011_h \)}}\\
              \pic{220613-2}
              }\\
              \hline
              \mc{\footnotesize{Hex} }\\
              \mc{\scriptsize{1 hex decimal is a Nibble, 4 bit}}\\
              \mc{\scriptsize{2 hex decimals are a byte}\\
              this is why bits are grouped into nibbles and bytes.}\\
              \mc{\scriptsize{Notation: 12 34 -> 0001 0010 0011 0100} \\
              just like with binary, we write the leading 0s for the memory size.}\\
              \mc{\scriptsize{biggest number possible with n bit:} \\ 
              \pic{220613-3}
              }\\
              \hline
              \mc{\footnotesize{Logical Operations} \\ \scriptsize{It is a function from n bits to 1 bit -> bool} \\ 
              \form{f: \mathbb{B}_n \text{ -> } \mathbb{B} \text{ || } f :: [a] \text{ -> } Bool}} \\
              \mc{\scriptsize{parameter: variable to use inside the function}} \\ 
              \mc{\scriptsize{argument: specific value used in a specific use} \\
              can also be described as fixed values. Note f(a,b) = a + g(a,b) \\ in this function
              the a and b in f are parameters, \\but in g they are arguments !!
              }\\
              \hline
              \mc{\scriptsize{Unary function: a function with 1 parameter}}\\
              \mc{\scriptsize{Binary function: a function with 2 parameters}}\\
              \mc{\scriptsize{Ternary function: a function with 3 parameters}}\\
              \mc{\scriptsize{n-ary function: a function with n parameters}}\\
              \mc{\scriptsize{Nullary function: function with zero parameters}}\\
              \hline
              \mc{\scriptsize{There are exactly 4 unary functions (with bits!)} \\ 
                \scriptsize{F(X) = 0 -> False || T(X) = 1 -> True}\\
                \scriptsize{id(x) = x, just like haskell id... }\\ 
                \scriptsize{not(x) = \( \not x\) }\\
              }\\
              \hline
              \mc{\scriptsize{There are 16 binary functions}}\\
              \mc{\scriptsize{Disjunction: OR \(x \lor v \)}}\\ 
              \mc{\scriptsize{Conjunction: AND \(x \land v\)}}\\
              \mc{\scriptsize{The others are made with unary, nullary or the 2 above}\\
              \pic{220613-4} \\ \pic{220613-5}\\
              note that some are actually unary or nullary,\\ 
              aka they don't actually do anything with the parameters.
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{tiny}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\scriptsize{NAND: the basis of modern computers} \\ 
              it is easy to create with transistors.\\
              It only results in False if both inputs are true,\\
              hence the name Not-AND.\\
              \scriptsize{mathematical notation:} \noskipform{\text{NAND} = x | y = \overline{x \land v}}\\
              \scriptsize{all base operations can be made with NAND} \\ 
              \pic{220613-6}
              }\\
              \hline
              \mc{\scriptsize{NOR} \\
              NOR is only true when neither of the inputs are true. \\ 
              aka NOR = 1 if x==0 \&\& y==0
              \form{ \overline{x \lor v}}
              \scriptsize{Just like with NAND, all functions} \\ \scriptsize{ can be made with NOR}}\\
              \hline
              \mc{\scriptsize{XOR: exclusive or} \\ 
              The XOR is true if only one input is true.\\
              \form{ x \oplus y} \\ 
              }\\
              \hline
              \mc{\scriptsize{Addition of bits.} \\ 
                \pic{220613-7}\\
                \scriptsize{\textcolor{Red}{AND signifies the overflow of bits. 1 0 <- 1 1}}\\
                \scriptsize{\textcolor{Red}{XOR signifies the addition of bits. 0 OR 1}}\\
              }\\
              \hline
              \mc{\scriptsize{Literal: variable or negation of variable: \(x_1 , \overline{x_2}\)}}\\
              \mc{\scriptsize{Conjunction-term: conjunction of literals \(x_1 x_2=x_1 \land x_2 \) }
              \vspace{-0.1in}}\\
              \mc{\scriptsize{Disjunction-term: disjunction of literals \(x_1 \lor x_2\)}}\\
              \mc{\scriptsize{Minterm: conjunction with ALL parameters of a function} 
              \vspace{-0.1in}}\\
              \mc{\scriptsize{Maxterm: disjunction with ALL parameters of a function}}\\
              \hline
              \mc{\scriptsize{Disjunctive Normalform DNF} \\ 
              \scriptsize{a disjunction of conjunctions. \(x_1 x_2 \lor \overline{x_1 x_2}\)}\\
              Functions are often displayed as DNF, since this format \\ requires only 3 symbols:
              \(\lor \land \lnot \) \\ 
              \scriptsize{The canonical DNF C-DNF: a DNF with all parameters} \\
              the canonical DNF is often used to display the true false table.\\
              The C-DNF is then often simplified to get the end result\\
              \pic{220613-8} \\ \pic{220613-9}\\
              note that DNF has nothing to do with the ferrari engine.\\
              }\\
              \hline
              \mc{logical function only return 1 or 0. In order to\\ return an entire number, we
              would have to map this function. \\ luckily there are several predefined mapped functions \\
              -- nor(x) invert all bits in x \\ 
              -- and(x,y) check the individual bits of x,y with and\\
              -- or(x,y) check the individual bits of x,y with or\\ 
              -- nor(x,y) check the individual bits of x,y with nor\\  
              }\\ 
              \hline
              \mc{\scriptsize{Bitwise operations in java...} \\ \pic{220613-10} \\
              \scriptsize{ || and \&\& are evaluations} \\ note that with || and \&\&, if the first
              evaluation is enough \\to determine the result, the second one won't be executed.\\
              a=False, b=True -> a \&\& b -> a is false, therefore result false.
              }\\
              \hline
              \mc{\scriptsize{Variable sizes in java} \\ \scriptsize{int = 32 bit} \\ 
              \scriptsize{short = 16 bit} \\ \scriptsize{byte = 8 bit} \\ \scriptsize{long 64 bit} \\
              Please note that these should only be used when, \\ you either save significant memory,
              or the integer isn't big enough.}\\
              \hline
              \mc{\scriptsize{multiplying a binary number} \\ 
              you have to multiply every single bit and add the corresponding 0s. \\ 
              \pic{220613-11} \\ 
              \pic{220613-12}
              }\\
              \hline
              \mc{\scriptsize{\textcolor{Red}{Multiplication with potences is just a leftshift!!}} \\
              \scriptsize{\textcolor{Red}{\(2^4 * 101 = \) add 4 0s to 101 -> 101'0000}}}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\scriptsize{\textcolor{Red}{Division with potences is a rightshift!!}} \\ 
              \scriptsize{\textcolor{Red}{\(\dfrac{1`0111}{2^3} =\) remove 3 bits from 1`0111 -> 101}}\\
              }\\
              \hline
              \mc{\scriptsize{Left \& Rightshift java} \\ 
                \scriptsize{logical right: a \r{> > >} x -> 101 \r{> > >} 1 -> 010}\\
                \scriptsize{logical left: a \r{< < <} x -> 101 \r{< < <} 2 -> 1`0100}\\
                \scriptsize{arithmic right: a \r{>>} x -> 101 \r{>>} 1 -> 110}\\
                \scriptsize{arithmic left: a \r{<<} x -> 101 \r{<<} 2 -> 1`0111}\\
                \scriptsize{the >>> and <<< add the MSB value instead of 0} \\
                \scriptsize{The reason for this is unsigned and signed!!}
              }\\
              \hline
              \mc{\scriptsize{Reading a bit} \\ \pic{220613-13}}\\
              \hline
              \mc{\scriptsize{Setting a bit} \\ \pic{220613-14}}\\
              \hline
              \mc{\scriptsize{Deleting a bit} \\ \pic{220613-15}}\\
              \hline
              \mc{\scriptsize{\r{Combine these with right and left shift!}} \\ 
                  \scriptsize{read: b \& (1 << n) >>> n} 000(b AND 11111...)\\
              \scriptsize{set: (b | (1 << n))} b OR 11111...\\
              \scriptsize{delete: b \& ~(1 << n)} b AND not 11111..\\
              \pic{220613-16}
              }\\
              \hline
              \mc{\footnotesize{Addition and Subtraction} \\ 
                \scriptsize{Addition: } \hspace{0.55in} \scriptsize{Subtraction: (Zweierkomplement)} \\
                \pic{220613-18} \pic{220613-19} \\ \pic{220613-20} \\
              }\\
              \hline
              \mc{\footnotesize{Signed \& Unsigned} }\\ 
              \mc{\scriptsize{Unsigned: only positive integers!}}\\
              \mc{\scriptsize{Signed: MSB 0 = positive, MSB 1 = negative }\\
              \scriptsize{the rest is a regular binary number.}\\
              note: This is something you simply need to know.\\ 
              It isn't included in some encoding!!\\
              \pic{220613-21} \\ \pic{220613-22} \\
              \scriptsize{note the difference in positive and negative} \\ 
              \scriptsize{in the signed category! size constraints!} \\ 
              \pic{220613-23} \\
              \scriptsize{Note -1 is 1111`1111. Negative numbers are}\\
              \scriptsize{calculated: 0 - number}\\
              This means an overflow on unsigned ints will lead \\ to it being 0 again.\\
              On signed ints, it will drop to negative maximum.\\
              \scriptsize{Special cases in signed:}\\
              \scriptsize{\(2^{n-1}\) max -> always negative as MSB = 1}\\
              \scriptsize{Max : 100000000...}\\
            \scriptsize{0 -> can't be negative as this bit is used for \(2^{n-1}\) }}\\
            \hline
              \mc{\scriptsize{Note that when increasing memory for signed values,} \\
              \scriptsize{you need to use the >> operators to copy the MSB.} \\
              \scriptsize{increasing memory for -1 -> 4 bit to 8 bit} \\ 
              \scriptsize{0000`1111 = 15 !! WRONG !! -> 1111`1111 = -1!!}\\
              }\\
              \hline
              \mc{\scriptsize{For signed left shift, check if you have spare memory} \\ 
              \scriptsize{left shift without checking might result in loss of MSB!}\\
              \scriptsize{4 bit max: 1001 < < < 2 = 0100 !! prefix changed !!}\\
              }\\
              \hline
              \mc{\scriptsize{multiplication: series of left shifts.} \\ 
              \mc{\scriptsize{1101 * 110 = 11`0100 + 1`1010 = 100`1110}\\
              10 -> add 1 zero, 100 -> add 2 zero, get the sum of both \\ 
              \scriptsize{Size increase: max double -> \(x^2\)}  \\
              110 * 110 -> 1100 + 1`1000 = 11`1000 (3 to 6 bits) \\
            }\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\pic{220613-28} \\ \scriptsize{Note that we don't need to care about signed, if } \\
              \scriptsize{we do not overwrite the MSB!}}\\
              \hline
              \mc{\scriptsize{Division} \\ 
              should be avoided, slow operation compared to others \\ 
              32 bit -> 20 times as long as multiplication \\ 
              64 bit -> 80 times as long as multiplication \\ 
              -- can be replaced with right shift for potences \\ see /10 for decimal numbers.\\
              signed and unsigned division are completely different \\
              \pic{220613-29}
            }\\
              \hline
              \mc{\footnotesize{Inversion} \\ 
                \form{N(b+1) > 2^n - 1 - b > 2^n == 0}
                \form{0-1 = -1 > 11111... > -1 - b = \overline{b}}\\
                Okay, the idea is that -1 is the number with all bits set to 1 \\
                This means that no matter what you do, you can't have overflow.\\
                In fact this means that b can be inverted by subtracting it to -1.\\
                \pic{220613-24}
              }\\
              \hline
              \mc{\scriptsize{Unsigned in java} \\
              You can't declare unsigned integer etc, instead you just use the \\ 
              unsigned functions. \\
              \pic{220613-25}}\\
              \hline
              \mc{\scriptsize{Java comparators} \\ \pic{220613-26}}\\
              \hline
              \mc{Beause processors are super fast in addition an subtraction, \\
              we can simplify equality checks by using these 2 operations.\\
              -- example unsigned, check if a < b: \\ \pic{220613-26} \\
              c is the carry bit, and it is only set to 1 if a < b!!\\
              -- example signed: \\ \pic{220613-27}\\
              -- the check for all 0 or 1 is also fast -> AND...\\
              In java we only work with the signed interpretation by default \\ 
              use the before mentioned special functions for unsigned!\\
              }\\
              \hline
              \mc{\footnotesize{Character Encoding} \\ 
              \scriptsize{A character is encoded via a bijectional function} \\
              \form{E'(z_0 .. z_{n-1})= f(E(z_0) .. E(z_{n-1}))}\\
              The formula must obviously be known by both parties, as the \\ 
              text can't be decoded otherwise.
              }\\
              \hline
              \mc{\scriptsize{ASCII}  \\ 
                \scriptsize{\( 2^7 = 128 -> 7 bit\)} \\ 
              \scriptsize{-- uses both printable characters and } \\
              \scriptsize{    nonprintable control characters} \\ 
              \scriptsize{-- introduction 1963, enacted by US president 1968}\\
              \\}\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{tiny}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\pic{220614-3} \\ 
                \scriptsize{\(00_h\) \textbackslash{}0 NULL: marker for End of text}\\
                \scriptsize{\(08_h\) \textbackslash{}b Backspace}\\
                \scriptsize{\(09_h\) \textbackslash{}t Tabspace}\\
                \scriptsize{\(0A_h\) \textbackslash{}n Line Feed, Newline}\\
                \scriptsize{\(0D_h\) \textbackslash{}r Carriage Return}\\
              }\\
              \hline
              \mc{\scriptsize{Problems with ASCII} \\ 
              --  Just another standard of many, even if it's the first \\
              --  Egnlish only, other languages can't to be encoded in ASCII\\
              -> hence no ä ö ü ...\\
              }\\
              \hline
              \mc{\scriptsize{Extensions for ASCII / Codepage} \\ 
              ASCII can be extended since it only uses 7 bit of the \\ 
              available 8. This means that the 8th bit can be used \\ 
              for other characters like ä.\\
              \scriptsize{range: \(80_h \text{ to } \text{FF}_h\)}\\
              \scriptsize{Extension announced with MSB = 1}\\
              \scriptsize{No extension MSB = 0}\\
              \scriptsize{Extended ASCII remains compatible to regular ASCII}\\
              \scriptsize{Many different Codepages defined in ISO.}\\
              Codepages have the problem that the sender and receiver \\ 
              need to again know what codepage is being used, since \\ 
              otherwise the receiver might not be able to decode \\
              certain characters properly.
              }\\
              \hline
              \mc{\footnotesize{Unicode} \\ 
              \scriptsize{UTF-8 (Standard) UTF-16 UTF-32}\\
              \scriptsize{max 17 · 64K - 2K = 1M + 62K = 1,112,064 Code-Points}\\
              \scriptsize{work in progress}\\
              }\\
              \hline
              \mc{\scriptsize{Codepoints(CP): Number of a character}\\
              \scriptsize{CodeUnit(CU): Unit for displaying encoded character}\\
              \scriptsize{UTF-32 -- all CP displayed with one CU}\\
              \scriptsize{UTF-16 -- all CP displayed with 1-2 CUs}\\
              \scriptsize{UTF-8  -- all CP displayed with 1-4 CUs}\\
              UTF-16 and 32 need to check for endianness \\ 
              since they are above 8 bit.\\
              \scriptsize{UTF-32 is limited to 21 bit!!} \\ 
              Rest often used for other things.
              }\\
              \hline
              \mc{\scriptsize{UTF-8}\\
              \scriptsize{UTF-8 it itself another ASCII extension}\\
              \scriptsize{UTF-8 -> 7 bit for characters }\\
              \scriptsize{\r{max 4 Bytes chained together -> 4x UTF-8 block}}\\
              \pic{220614-6} \\ \pic{220614-7} \\ \pic{220614-8} \\
              }\\
              \hline
              \mc{\scriptsize{UTF-16} \\ 
              \scriptsize{\r{max 4 Bytes chained together -> 2x UTF-16 block}}\\
            \pic{220614-9}\\}\\ 
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\pic{220614-10} \\ \pic{220614-11}\\
                \scriptsize{\(U_1 (D800 \leq U_1 \geq \text{DBFF})\) is the high surrogate}\\
                \scriptsize{\(U_0 (DC00 \leq U_0 \geq \text{DFFF})\) is the low surrogate}\\
              \scriptsize{codepoints above \(10000_h\) are supplementary codepoints}\\
              \scriptsize{codepoints c with \(\text{p0000}_h \leq c \leq \text{pFFFF}_h \) are on plane p}\\
              \scriptsize{p = 0 is the basic multilingual plane -> 1 UTF-16 block}\\
              \scriptsize{\(1 \leq p \leq 16\) are the supplementary planes}\\
              }\\
              \hline
              \mc{\scriptsize{UTF-32} \\
              \scriptsize{first 11 bits used for other things}\\
              \scriptsize{Big-Endian by default -> convert for little endian}\\
              \scriptsize{21 significant bits}\\
              \scriptsize{max 4 bytes -> ONLY 1 UTF-32 block}\\
              Most used internally in programming languages \\ 
              and or applications.\\
              }\\
              \hline
              \mc{\scriptsize{Byte-Order-Mark (BOM) \(\text{FEFF}_h\)} \\ 
              If this is at the start of a file, \\
              then you can read the encoding from it: \\
              \pic{220614-12}\\
              }\\
              \hline
              \mc{\scriptsize{Encoding examples}\\
              \pic{220614-13}}\\
              \hline
              \mc{\footnotesize{Enian(ness)} \\ 
              \scriptsize{Big-endian and Little-endian}\\
              \scriptsize{Big-endian -> MSB leftmost bit, LSB rightmost bit}\\
              \scriptsize{Little-endian -> MSB rightmost bit, LSB leftmost bit}\\
              \pic{220614-4}\\
              Important since for example Intel processors have 1 Byte \\ 
              as the smallest adressable unit. This means you need \\ 
              to know the Endian of that byte, as you otherwise \\ 
              wouldn't be certain if you hit the LSB or the MSB first.\\
              }\\
              \hline
              \mc{\scriptsize{Endian Problem} \\ 
                \scriptsize{\r{Little-endian is objectively better}}\\
              example: accessing the first 8 bits from a 16 bit number.\\
              It would make sense to only request the 8 bits, but \\ 
              this doesn't work for big Endian as\\
              it ends with the smallest number. \\
              \pic{220614-5} \\
              For little endian, the access could have been smaller -> 8 bit.\\
              Thank fibonacci for fucking up his translation of numbers.\\
              }\\
              \hline
              \mc{\scriptsize{Endian Problem solution}\\
              \scriptsize{-- shift to Mixed or Middle endian} \\
              \scriptsize{-- Acceptance of both Endians}\\
              These solutions are needed since it is unlikely that \\
              there will unity with endianness.
              }\\
              \hline
              \mc{\scriptsize{Encoding in Java} \\ 
              \scriptsize{Char receives a UTF-16 Code Unit}\\
              \scriptsize{Strings are an object with length and CodePoints}\\
              This is different from C where you have to iterate \\ 
              to find the NULL symbol 0x00. Java uses more memory \\
              but it is faster to check length etc.\\
              \pic{220614-14} \\ \pic{220614-15} \\
              Certain operations are not permitted on Strings directly\\
              such as + - delete, insert, replace etc\\ 
              as they would change the string, and a string is immutable!\\
              \scriptsize{To mitigate this problem, use buffers and Stringbuilder}\\
              }\\
              \hline
              \mc{\scriptsize{ByteBuffer, CharBuffer, IntBuffer}\\ 
              \scriptsize{contains: array, capacity, limit and pos}\\
              -- array is the storage for the type -> char, int \\ 
              -- capacity is the size of the entire buffer, it is immutable\\
              -- limit is the amount of changeable elements inside the buffer\\
              -- pos is the relative position for read and write operations\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\ \pic{220614-16}\\ \pic{220614-17}}\\
              \hline
              \mc{\scriptsize{InputStreams} \\ 
              \scriptsize{Sequential processing of bytes}\\
              int read() -> 0-255 per byte \\ 
              int read(byte[] d, int s , int c) amount of read bytes \\ 
              int read(byte[] d)\\ 
              all of these function return -1 for exceptions\\
              \scriptsize{FileInputStream}\\
              reads data via functions from the operating system.\\
              should only be used in combination with read(byte[], ...) \\
              as it would be extremely slow otherwise.\\
              \scriptsize{BufferedInputStream}\\
              reads data form another Stream and bufferes it.\\
              very fast read()\\
              if size is unknown then other streams should be used.\\
              \pic{220614-18}\\
              \scriptsize{InputStreamReader} \\ 
              read form an InputStream \\ 
              has to convert bytes into chars\\
              It uses a decoder d as specified: \\
              \pic{220614-19}\\
              \scriptsize{Charsets in Java} \\ 
              Charset.newDecoder() or Charset.newEncoder() \\
              create decoder or encoder.\\
              static SortedMap<String,Charset> Charset.availableCharsets()\\
              returns all available Charsets for this VM.\\
              \scriptsize{FileReader (extends FileInputStream)}\\
              -- just calls super(FileInputStream)
              -- only available with default encoder\\
              -- for more encoders you have to call FileInputStream manually\\
              \scriptsize{BufferedReader}\\
              -- reads data blockwise from a reader and buffers it\\
              check BufferedInputStream for similarity \\ 
              String readLine(): gives all chars until next line\\
              \pic{220614-20}\\
              }\\
              \hline
              \mc{\scriptsize{Streams and Resource-Leaks}\\
              Because most Streams need resources from the OS, \\
              we need to close these streams again. Otherwise leak!\\
              The try is for possible exceptions, obviously\\
              \pic{220614-21}\\
              or the simplified and more safe way (\r{Try-With-Resources}): \\
              (em.close can cause exception!)\\
              \pic{220614-22}\\
              -- types have to extend the closeable type. \\ 
              -- resources are automatically closed in the opposite manner\\
              -- try with resources guarantees safe closing.\\
              }\\
              \hline
              \mc{\scriptsize{Units in Programming languages} 
              Obviously there is no type of km, or kg..\\
              We therefore use comments to signify the km or kg for humans\\
              Keep in mind that this means we also have to implement the \\
              conversion ourselves, as the computer doesn't know you want \\ 
              to calculate meters + kilometers!!\\
              \pic{220614-23}}\\
              \hline       
              \mc{\scriptsize{Fixed Point Numbers: Integers with Commas!}\\
              \pic{220614-24}\\
              adding K to K then converting is very easy:\\
              \pic{220614-25}\\
              even adding a single bit is not that hard\\
              however note the ending 5.000... oof \\
              \pic{220614-26} \\
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{tiny}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{This can still be displayed, but: \\
              \pic{220614-27}\\
              5.001 can't be displayed, only the one on the left and right.\\
              Inaccuracy due to integer limitations! \\
              \scriptsize{only multiples of \(2^{-10}\) can be displayed}\\
              }\\
              \hline
              \mc{\scriptsize{Biggest number in Klotz} \\ 
              \pic{220614-28}\\
              Note that \(\Sigma_{k=0}^31\) due to Integer being max 32 bit!\\
              \scriptsize{Cut Numbers after comma} \\ 
              \pic{220614-29} \\
              \scriptsize{Cut Numbers before comma} \\ 
              \pic{220614-30} \\
              \pic{220614-31} \\ 
              \pic{220614-32}
              }\\
              \hline
              \mc{\footnotesize{Floating Point Numbers} \\\\ 
              \scriptsize{\r{prefix MSB s: 1 bit}}\\
              \scriptsize{\r{Significand z: BitString of number}} \\ 
              \scriptsize{\r{Exponent a: float -> 8, double -> 11}}\\
              \scriptsize{\r{Encoded Exponent k: explained below}}\\
              \scriptsize{\r{bias b: \(-(2^{e-1} -1)\)}}\\
              \scriptsize{\r{precision p: float -> 24, double -> 53}}\\
              \pic{220614-33} \\
              \scriptsize{Different forms of floating point numbers:} \\ 
              \pic{220614-34}
              }\\
              \hline
              \mc{\scriptsize{Normalized Numbers} \\ 
              \pic{220614-35} \\ 
              \scriptsize{\r{The hidden bit is NOT an actual bit!!}}\\
              \scriptsize{\r{It is used inside the formula for calculation!}}\\
              }\\
              \hline
              \mc{\scriptsize{Encoding of Exponents} \\ 
              \scriptsize{The bitpatterns 0..0 and 1...1 are not valid exponents}\\
              \scriptsize{\r{The exponent is encoded as k = a - b, b = \(-(2^{e-1} -1)\)}}\\ \vspace{-0.03in} \\
              \scriptsize{\(\text{-> } k \in [1,2^e - 2]\) }\\
              \scriptsize{\(\text{-> } a \in [-(2^{e-1} - 2), 2^{e-1} - 1] = [-(b - 1), b]\)}\\
              -- for float : \( b = 2^{8-1} - 1 = 127 \land a \in [-126, 127] \)\\
              -- for double : \( b = 2^{11 - 1} - 1 = 1023 \land a \in [-1022,1023] \)\\
              }\\
              \hline
              \mc{\scriptsize{Value of a floating point number} \\ 
                \form{W(x) = (-1)^s * 2^{k+b} * (1 + (z * 2^{-(p-1)}))}\\
                \scriptsize{Example: Note z is the variable here, not the significand} \\ 
                \pic{220614-36}\\
                \scriptsize{Special Values:} \\ 
                \pic{220614-37} \\ 
              }\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\pic{220614-38} \\ 
              }\\
              \hline
              \mc{\footnotesize{Rounding Modes} \\ 
              \scriptsize{mathematical operations are done before rounding!}} \\ 
              \hline
              \mc{\scriptsize{Round to nearest:} \\
              \r{submode 1: Ties to Even:} round to an even number, LSB = 0\\
              0.1 -> 0, 1.1 -> 2.0, 3.2 -> 2.0 \\
              -- cancels itself out over time\\
              -- better when numbers with 0.1 are added\\
              -- \r{default variant}\\
              \r{submode 2: Ties away from Zero} \\ 
              Round to next number 1.1 -> 2.0}\\
              \hline
              \mc{\scriptsize{Round toward Zero:} truncate -> 1.5325 -> 1.0}\\
              \hline
              \mc{\scriptsize{Round toward +Infinity:} Ceiling 1.1 -> 2.0}\\
              \hline
              \mc{\scriptsize{Round toward -Infinity:} Floor, 1.9 -> 1.0}\\
              \hline
              \mc{\scriptsize{Rounding errors} \\ 
              \pic{220614-39}\\
              \scriptsize{This error can now be quantified:} \\ 
              first we display a real number x as a floating point number\\
              \form{W(x) \text{ -> } x\in \mathbb{R} }\\
              \scriptsize{The absolut error \r{E} is:} \\ 
              \form{E(x) = |W(x) - x| }\\
              \scriptsize{The relative error \r{e} is:}\\
              \form{e(x) = \left|\dfrac{E(x)}{x}\right| = \left|\dfrac{R(x) - x}{x} \right|}\\
              \scriptsize{For the number from before, an example:} \\ 
              \pic{220614-40}\\
              \pic{220614-41}
              }\\
              \hline
              \mc{\scriptsize{Machine Epsilon: \(\epsilon\) The biggest possible error} \\
              \form{\epsilon = 2^{-24} = 2^{-2}} \\ 
              The smallest number \(\epsilon \), so that \(1 + \epsilon > 1 \)\\
              Note: the worst error is therefore always the flip of a highest bit\\
              In this case the flip of \(2^{-23}\) to 1 after \(2^{-24}\) was rounded.\\ 
              }\\
              \hline
              \mc{\scriptsize{In Programming languages the epsilon is defined as:}\\
              \scriptsize{the distance from 1 to the next smallest number \(2^{-23}\)}\\
              Therefore the biggest error is often \\
              a slight bit bigger than we have defined \\ 
              \pic{220614-42}\\}\\
              \hline
              \mc{\scriptsize{Float and Double in Java} \\ 
              \scriptsize{double default when using . -> 0.5 }\\
              optionally defined with d -> 0.5d\\
              \scriptsize{float -> 0.5f f is necessary!}\\
            }\\
            \hline
          \mc{\footnotesize{Addition of floating point numbers }\\
            \scriptsize{1. check prefix, if different do subtraction} \\
            \scriptsize{2. set prefix for result -> 0 or 1}\\
            \scriptsize{3. if exponents are different, shift smaller number to right}\\
            \r{First shift a single 1 -> hidden bit !} \\
            \r{Shift the rest with 0s}\\
            \scriptsize{4. do addition just like with integers} \\ 
            \scriptsize{5. (if carry == 1) normalize result}\\
            \r{increment exponent by one}\\
            \r{shift significand to the right by 1}\\
            \pic{220614-43}\\
        }\\
            \hline
            
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{Guard digits} \\ 
              \scriptsize{-- just as hidden as the hidden bit} \\ 
              \scriptsize{-- implemented in hardware not software}\\ 
              \scriptsize{-- essentially a flag for rounding!}\\
              \pic{220614-44} \\ 
              \pic{220614-45}
            }\\
            \hline
            \mc{\footnotesize{Special cases for floating point numbers}
              \scriptsize{\(\pm 0\) -> a = 0 .. 0 \& z = 0 .. 0}\\
              \scriptsize{subnormal number -> a = 0 .. 0 \& z NOT 0 .. 0}\\
              \scriptsize{\(\pm \infty\) -> a = 1 .. 1 \& z = 0 .. 0}\\
              \scriptsize{NaN -> a = 1 .. 1 \& z NOT 0 .. 0}\\
              The reason we want things such as infinity is this: \\
              \pic{220614-46}\\
              We either check for overflows the entire time! \\ 
              Or we just continue calculation with infinity \\ 
              And then at THE END we check if it's infinite \\ 
              \pic{220614-47}
            }\\
            \hline
            \mc{\footnotesize{Calculation with \(\infty \)}
              \scriptsize{exchange \(\infty \) with x and define: \(\lim{x\to\infty} \)}\\
              \scriptsize{if the limit exists, the result is the limit}\\
              \scriptsize{if the limit doesn't exist, result is NaN}\\
              \pic{220614-48}\\
            }\\
            \hline
            \mc{\footnotesize{Calculation with NaN}\\
            \scriptsize{\r{ALL OPERATION WITH NaN RESULT IN NaN!}}\\
            \scriptsize{Other operations might also result in NaN:}\\
            \pic{220614-49}\\
            There are also some implementations for exceptions inside floating points:\\
            qNaN: propagates exception\\
            sNaN: throws exception\\
            }\\
            \hline
            \mc{\footnotesize{+0/-0}\\
            \scriptsize{+0 is the underflow for positive numbers}\\
            \scriptsize{-0 is the underflow for negative numbers}\\
            This is important since certain functions like log\\
            are only defined for positive numbers, \\
            therefore we need a positive 0.\\
            Should we have a rounded down negative number\\
            then we would still want a negative 0 \\
            otherwise it would suddenly be considered to be positive.\\
            }\\
            \hline
            \mc{\footnotesize{Subnormal Numbers} \\
            \scriptsize{No hidden bit! Used when the exponent is too small} \\ 
            \form{V(x) = (-1)^s * 2^{-(b-1)} * z * 2^{p-1}}\\
            Often used as a gradual underflow \\
            or for semi results during a calculation\\
            \pic{220614-50}\\
            }\\
            \hline
            \mc{\footnotesize{Integers as Floating Point Numbers}\\
            \form{G(x) = 2^{k-b} * 1}\\
            Regular numbers obviously don't need comma shifting!!\\
            \scriptsize{16million + 1 is the smallest number that can't be displayed}\\
            -- a=23 only integers can be displayed\\
            -- a=24 only even numbers can be displayed\\
            -- a=25 only numbers divisible by 4 can be displayed\\
            -- a=26 only numbers divisible by 8 can be displayed\\
            -- \(a \pm 23 \) only numbers divisible by \(2^{a-23}\) can be displayed
            }\\
            \hline
            \mc{\footnotesize{check page 2 for floating point comparison!}}\\
            \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
\end{document}
