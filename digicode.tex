\documentclass{article}
\usepackage[left=-1.5mm, right=-1.5mm, top=-1mm, bottom=-1.5mm]{geometry}
\usepackage[document]{ragged2e}
\usepackage{graphicx}
\usepackage{amsmath, mathtools, nccmath, amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage{array, makecell}
\usepackage[T1]{fontenc}
\usepackage{noto-sans}
\renewcommand\cellalign{cl}
\renewcommand\theadalign{lc}
\newcommand{\ns}{\\ \vspace{-0.03in}}
\newcommand{\mc}[1]{\makecell[cl]{\vspace{-0.065in} \\ #1}}
\newcommand{\mcc}{\makecell[{{c}}]}
\newcommand{\mcr}{\makecell[{{r}}]}
\newcommand{\pic}{\includegraphics[scale=0.3]}
\newcommand{\form}[1]{\vspace{-0.03in}\\ \small{\textcolor{Red}{\(#1\)}} \\ \vspace{-0.03in}}
\newcommand{\noskipform}[1]{\small{\textcolor{Red}{\(#1\)}}}
\newcommand{\fpic}{\vspace{-0.05in} \\ \includegraphics[scale=0.3]}
\renewcommand{\b}{\textbf}
\renewcommand{\r}[1]{\textcolor{Red}{#1}}
%\renewcommand{\arraystretch}{1.5}
\graphicspath{{./Pictures/}}
\begin{document}
    \begin{table}[ht!]
        \begin{tiny}
          \begin{tabular}{ccc}
          \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\b{Number Base Case} \\ \(N= d_n R^n + d_1 R^1 + d_0 R^0 \) \\ the d specifies the Number system -> \(d_2\) == binary \\ 
              can also be written as \(R_2\) \\ 
              This can also be used to expand numbers: \\ \(N_{10} 255 = 2 * 10^2 + 5 * 10^1 + 5 * 10^0 \) \\ \(N_2 110 = 1 * 2^2 + 1 * 2^1 + 0 * 2^0 => N_{10} 6\)}\\
              \hline
              \mc{\b{Quantities:} \\ \b{N} -> natural numbers  | |  \b{Z} -> full numbers \\  \b{Q} -> rational numbers | | \b{R} -> real numbers}\\
              \hline
              \mc{\b{Common number systems:} \\ Decimal: \(N_{10} = n * 10^n .. 0 * 10^0\) \\ \b{Binary:} \(N_2 = n * 2^n .. 0 * 2^0\) \\
                \(2^{10}=1024, 2^9=512, 2^8=256, 2^7=128, 2^6=64,\) \\  \(2^5=32, 2^4=16,2^3=8, 2^2=4, 2^1=2, 2^0=1\) \\ \b{Hexadecimal:} \(N_16 = n * n^{16} .. 0 * 16^0\) \\ 
              notation: 0 1 2 3 4 5 6 7 8 9 A B C D E F \\ \(16^5=1048576, 16^4=65536, 16^3=4096, 16^2=256,\) \\  \(16^1=16, 16^0=1\) }\\
              \hline
              \mc{\b{Modulo} \\ 8 mod 4 = (8) -> 0 , 8 mod 3 = (6) -> 2 , 8 mod 5 = (5) -> 3 \\ if x<y in x mod y then the result will always be x! \\ 
              any negative numbers can be considered as NOTnegative\\ aka only absolute values! modulo deals with |x| \\ many programming languages actually do not follow this! \\
              they have their own implementation of modulo. \\ 5 \(\equiv\) 3 mod 2 -> as 5 mod 2 = 1 and 3 mod 2 = 1 }\\
              \hline
              \mc{\b{Codeword length} \\ \b{Byte = 8 bit} || \b{Word = 16 or 32 bit} \\ TCP packet = 1024 bit }\\
              \hline
              \mc{ \b{Cyclic group} \\ \pic{220610-19} \\ \pic{220610-18}} \\ WHAT THE FUCK \\
              \hline
              \mc{\b{Result Quantity} the result of all possible outcomes \\ it is denoted with: \(\Omega\) \\ A single element of the result list is: \(\omega\)  -> \(\omega \in  \Omega \) \\ 
              The list of results is \(|\Omega|\) \\ Example Dice roll: \(\Omega = \{1,2,3,4,5,6\}\) }\\
              \hline
              \mc{\small{Probability: \textcolor{Red}{\(P(A) = \dfrac{\text{best results}}{\text{all results}}= \dfrac{|A|}{|\Omega|} = \dfrac{|A|}{n}\)}} \\
              So what is the probability of rolling a 6? \\ 
              \(P(\text{desired number to roll}) = \dfrac{\text{only 1 good result!}}{\text{6 possible results}} = \dfrac{1}{6}\) \\ hence the chance is 1 in 6 \\ Why this complicated method?
              You can modify desired results! \\ just change the A in P(A)!}\\
              \hline
              \mc{\b{Inverse Probability: P(inverse) = 1 - P(A)} \\ dice -> \(1 - \dfrac{1}{6} = \dfrac{5}{6}\) \ns }\\
              \hline
              \mc{\b{Addition rule:}\\ \form{P(A\cup B) = P(A) + P(B) - P(A\cap B)} \\ !!The last part is needed, as otherwise the number \\ would exceed the possible states!! \\ \vspace{-0.05in}\\
              \r{\(P(A\cup B \cup C) = P(A) + P(B) + P(C) - P(A\cap B) - P(A\cap C)\)} \\ \textcolor{Red}{\(- P(B\cap C) + P(A\cap B\cap C)\)}}\\
              \hline
              \mc{\b{Amount of possibilities:} \\ \b{ordered probes with replication:} \\ 2 coins, head and tail, possibilities? \b{k}=head/tail=2 \b{n}=coins=2 \\ \form{\Omega = n^k = 2^2} \\
              \b{ordered probes without replication:} \\ 5 dices. How many combinations? \\  dice numbers = \b{n} = 6 (1-6), dice amount = \b{k} = 5 
              \\ possibilities = \(\Omega = \dfrac{n!}{(n-k)!} = 
              \Omega = \dfrac{6!}{(6-5)!} = 720\) \\ Or this: \\ \form{\Omega = \Pi^{n-k+1}_{n} n = \Pi^{6-5+1}_{6} 6 = 2*3...5*6 = 720} \\
              \b{unordered probes wihout replication:} \\ 25 players, each should only play once with the other. \\ \(\Omega = \dfrac{n!}{k!(n-k)!}\) -> \(\dfrac{25!}{2!(25-2)!}\) -> 
              \(\dfrac{\text{too big}}{\text{too big}} = 300 \) \\
              as you can see the bottom is a BIG calculation, so \\ \form{ \Omega = \dfrac{\Pi^{n-k+1}_{n}n}{k!} \text{->} \dfrac{\Pi^{25-2+1}_{25}25}{2!}
              \text{->} \dfrac{24*25}{2} = 300 } \\ Note that \b{k} can also be defined as the \\ length of the tuple we want to receive. \\ -> (Player,Player) - > 2}\\
              \hline
              \mc{\b{Source to Sink Information} \\ \pic{220610-20} }\\
              \hline
              \mc{\small{\b{Entropy}} \\ \footnotesize{information content} \\ this essentially just us how many bits are needed \\ 
              \b{k} is base state count -> bit = 2 \\ and \b{N} is the full number of states \\ 
            example: list {True,False,True,False} 4 states total, base 2. \\ \form{H_0 = log_k(N) [k] \text{ -> } H_0 = log_2(4) [bit] = 2} }\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{information flow} \\ essentially information content over time \\ \form{H^*_0 = \dfrac{log_2(N)}{\tau}[\dfrac{bit}{s}]} \\ 
              \footnotesize{information quantity / Surprise} \\ \form{I(x_k) = -log_2(P(x_k))[bit]} \\ 
              \footnotesize{Entropy (Surprise per element)} \\ 0 means no symbols. 1 means perfect balance 50-50 \\ \form{H(X) = \Sigma^N_{k=1} P(x_k) * I(x_k) [\dfrac{bit}{symbol}] } \\ where X is the list of symbols
              \\ \footnotesize{Sink Redundance / Code Reduncance} \\ \begin{tabular}{@{\hskip1pt}m{4cm}m{2cm}}\vspace{-0.15in}\noskipform{R_Q = H_0 - H(X) [\dfrac{bit}{symbol}]}
              \noskipform{R_c = L - H(X) [\dfrac{bit}{symbol}]} & 
              \vspace{-0.25in}\pic{220610-21} \end{tabular} \\ 
              \footnotesize{Code Word Length} \\ \form{L(x_k) = \text{rounded}(I(x_k))[bit]} \\
              \footnotesize{Median Code Word Length} \\ \form{L = \Sigma^N_{k=1}P(x_k) * L(x_k) [\dfrac{bit}{symbol}] } \\ 
              \footnotesize{Entropy of the entire Code} \\ \form{H_c(X) = \Sigma^N_{k=1} P(x_k) * L(x_k) [\dfrac{bit}{symbol}]} \\ \footnotesize{\(H_c\) can be a real number -> \(H_c \in  \mathbb{R} \)}
              }\\
              \hline
              \mc{\fpic{220610-22}}\\
              \hline
              \mc{\footnotesize{Sink without memory} \\ \form{P(x_k,y_k) = P(x_k) + P(y_i)} \\ \footnotesize{Sink with memory} \\ \form{P(x_k,y_i) = P(x_k) + P(x_k|y_i)} \\
              \footnotesize{Entropy without memory / Combined Entropy} \\ \form{H(H,Y) = \Sigma^N_{x_k} \Sigma^N_{y_i} P(x_k,y_i)*(-log_2(P(x_k,y_i))} \\
              or: \(H(X,Y) = H(X) + H(Y) \) \\
              \footnotesize{Entropy with memory} \\ \form{H(H,Y) = \Sigma^N_{x_k} \Sigma^N_{y_i} P(x_k) * }\\ \vspace{-0.1in}\form{P(x_k,y_i)*(-log_2(P(x_k) * P(x_k|y_i))}
              }\\
              \hline
              \mc{\footnotesize{Encoding of Symbols} \\ \pic{220610-23} \\ \pic{220610-24} \\ continue this pattern until every symbol has a code \\ note the extra 0 on every step }\\
              \hline
              \mc{\footnotesize{Run Length Encoding RLE/RLC} \\ \pic{220610-25}}\\
              \hline
              \mc{\b{Encoder and Decoder} \\ You need to either choose 1 or 0 as the starting \\ bit. After that the decoder can print out the correct code.}\\
              \hline
              \mc{\b{Chiffre text} \\ You can "encrypt" your data by \\ shifting the codes by a certain amount. \\ In the caesar chiffre this is done with the number 4. a -> e\\ 
              Please do not use this, use RSA or other algorithms.}\\
              \hline
              \mc{\footnotesize{Errors} \\ \pic{220610-26} \\ \pic{220610-27}}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{Conditional Entropy -> Entropy of Y given X} \\  
              \form{H(Y|X) = \Sigma^N_{k=1} \Sigma^N_{i=1} P(x_k,y_i) * (-log_2(\frac{P(x_k,y_i)}{P(x_k)}))} \\ 
              \footnotesize{Chain Rule} \\ \form{H(Y|X) = H(X,Y) - H(X) \text{ || } H(Y \backslash X)} \\ 
              \footnotesize{Bayes Rule} \\ \form{H(Y|X) = H(X|Y) - H(X) + H(Y) \text{ || } H(Y\backslash X)} \\
              \pic{Entropy} \\
              \footnotesize{Transinformation} \\ likelyhood of information being correct at arrival. \\ 
              \form{T = H(X) - H(X|Y) \text{ || } H(Y) - H(Y|X)} \form{\text{or: }|(X;Y)}
              }\\
              \hline
              \mc{\footnotesize{Hamming distance / distance to next valid codeword} \\ \form{h =Min_{i,j}(d(x_i,x_j))} \\
                \footnotesize{error detection distance} \\ the amount of bits that differ from input to output \\ 
              \form{e^*=h-1} \\
                \footnotesize{error correction distance for h even} \\ \form{h=2e+2 \text{ -> } e = \dfrac{h - 2}{2}}
                \footnotesize{error correction distance for h uneven} \\ \form{h=2e+1 \text{ -> } e = \dfrac{h - 1}{2}}\\
                  Consider the valid input either 111 or 000. \\  The Hamming distance \b{h} is therefore 3 bits. \\ The detection distance \b{ \( e^* \) } is 3 - 1 \\
                  Due to h being uneven, the correction distance \b{e} is \(\dfrac{h - 1}{2}\) \\ which results in 1.
              }\\
              \hline
              \mc{\footnotesize{tighly packed coderoom} \\ n = dimension of code \vspace{-0.05in}\\ m = dimension of messages \noskipform{2^m * \Sigma^e_{w=0} (^n_w) \leq 2^n}\\
                k = dimension of control -> n = m + k \\ The code is considered to be tightly packed \\ if the equation has the result 2. aka == not smaller. \\ %\pic{220611-2}
              }\\
              \hline
              \mc{\footnotesize{Hamming Codes} \\ The hamming code is very easy to implement \\ \form{\Sigma_i x_i * \overrightarrow{\rm P_i} \equiv \overrightarrow{\rm 0} mod 2} \\
              \footnotesize{The syndrome} \noskipform{\overrightarrow{\rm Z} = \Sigma_i x_i * \overrightarrow{\rm P_i} mod 2} \\ 
              \pic{220612-1} \\ \pic{220612-2} \\
              note that the 001 010 100 of the parity checks are \\ simply the unit vector \(\overrightarrow{\rm 0}\) !!!
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{tiny}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{
              \footnotesize{parity checks needed:} \\ \form{par = log_2(\text{bit amount of code})} \\
              \footnotesize{1101 = 4 bits -> 3 parity checks} \\ \footnotesize{as 4 can be displayed by 3 bits -> 100}\\
              \pic{220612-3}
              }\\
              \hline
              \mc{\footnotesize{convolutional code / folding code} \\ \pic{220612-4}\\
              }\\
              \hline
              \mc{\footnotesize{Viterbi algorithm / Decoding convolutional code} \\ \pic{220612-5} \\ \pic{220612-6} \\ \pic{220612-7}}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{Input - Output ratio for convolutional codes} \\ \form{R=\dfrac{input}{output} \text{ in example } R=\dfrac{1}{2}} }\\
              \hline
              \mc{\footnotesize{hamming code extension} \\ \pic{220613-17}}\\
              \hline
              \mc{\footnotesize{RSA} \\ 
              }\\
              \hline
              \mc{\footnotesize{RINKEL DONE}}\\
              \hline
              
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\footnotesize{potence system} \\ decimal binary and hexadecimal are all built the same way \\ 
              \form{W_a(z) = \Sigma^{n-1}_{i=0} z_i * a^i = z_{n-1} * a^{n-1} + }
              \form{z_{n-2} * a^{n-2} + ... + z_1 * a^1 + z_0 * a^0}
              }\\
              \hline
              \mc{\footnotesize{Terms in the binary form}}\\ 
              \hline
              \mc{\scriptsize{Bit = 1} set bit }\\ 
              \hline
              \mc{\scriptsize{Bit = 0} cleared bit} \\
              \hline
              \mc{\scriptsize{LSB} Least Significant Bit, rightmost bit, bit 0}\\
              \hline
              \mc{\scriptsize{MSB} Most Significant Bit, leftmost bit, bit (n-1)}\\
              \mc{\scriptsize{!!Note that this is for little-endian!!} \\ \scriptsize{big-endian is 
              the opposite!!}}\\
              \hline
              \mc{\scriptsize{Nibble} a 4 bit binary number\\ bigger numbers get grouped into nibbles
              -> 1101 0101} \\
              \hline
              \mc{\scriptsize{Octett} a binary number with 8 bit}\\
              \hline
              \mc{\scriptsize{byte} 8 bit}\\
              \hline
              \mc{Note, in binary the leading 0s will still be written, \\ in order to indicate
              how big the memory allocation is.}\\
              \hline
              \mc{\scriptsize{indices in bits} in order to change single bits in a number, \\ 
              we can use the array notation. b=1010 b[3]=1 b=1011}\\
              \hline
              \mc{\scriptsize{amount of numbers to display} \\ binary: \(2^n\) numbers -> n=bits\\
              The amount of numbers to double every increase of potence.\\
              Note: There are no broken binary numbers. It's always \(2^n\) \\ 
              with n being an integer!!
              }\\
              \hline
              \mc{\footnotesize{prefixes} \\ \pic{220613-1} \\ 
                \scriptsize{suffixes: \textcolor{Red}{\(\text{binary:} 1011_b, \text{hex:} 1011_h \)}}\\
              \pic{220613-2}
              }\\
              \hline
              \mc{\footnotesize{Hex} }\\
              \mc{\scriptsize{1 hex decimal is a Nibble, 4 bit}}\\
              \mc{\scriptsize{2 hex decimals are a byte}\\
              this is why bits are grouped into nibbles and bytes.}\\
              \mc{\scriptsize{Notation: 12 34 -> 0001 0010 0011 0100} \\
              just like with binary, we write the leading 0s for the memory size.}\\
              \mc{\scriptsize{biggest number possible with n bit:} \\ 
              \pic{220613-3}
              }\\
              \hline
              \mc{\footnotesize{Logical Operations} \\ \scriptsize{It is a function from n bits to 1 bit -> bool} \\ 
              \form{f: \mathbb{B}_n \text{ -> } \mathbb{B} \text{ || } f :: [a] \text{ -> } Bool}} \\
              \mc{\scriptsize{parameter: variable to use inside the function}} \\ 
              \mc{\scriptsize{argument: specific value used in a specific use} \\
              can also be described as fixed values. Note f(a,b) = a + g(a,b) \\ in this function
              the a and b in f are parameters, \\but in g they are arguments !!
              }\\
              \hline
              \mc{\scriptsize{Unary function: a function with 1 parameter}}\\
              \mc{\scriptsize{Binary function: a function with 2 parameters}}\\
              \mc{\scriptsize{Ternary function: a function with 3 parameters}}\\
              \mc{\scriptsize{n-ary function: a function with n parameters}}\\
              \mc{\scriptsize{Nullary function: function with zero parameters}}\\
              \hline
              \mc{\scriptsize{There are exactly 4 unary functions (with bits!)} \\ 
                \scriptsize{F(X) = 0 -> False || T(X) = 1 -> True}\\
                \scriptsize{id(x) = x, just like haskell id... }\\ 
                \scriptsize{not(x) = \( \not x\) }\\
              }\\
              \hline
              \mc{\scriptsize{There are 16 binary functions}}\\
              \mc{\scriptsize{Disjunction: OR \(x \lor v \)}}\\ 
              \mc{\scriptsize{Conjunction: AND \(x \land v\)}}\\
              \mc{\scriptsize{The others are made with unary, nullary or the 2 above}\\
              \pic{220613-4} \\ \pic{220613-5}\\
              note that some are actually unary or nullary,\\ 
              aka they don't actually do anything with the parameters.
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
    \pagebreak
    \begin{table}[t]
        \begin{tiny}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\scriptsize{NAND: the basis of modern computers} \\ 
              it is easy to create with transistors.\\
              It only results in False if both inputs are true,\\
              hence the name Not-AND.\\
              \scriptsize{mathematical notation:} \noskipform{\text{NAND} = x | y = \overline{x \land v}}\\
              \scriptsize{all base operations can be made with NAND} \\ 
              \pic{220613-6}
              }\\
              \hline
              \mc{\scriptsize{NOR} \\
              NOR is only true when neither of the inputs are true. \\ 
              aka NOR = 1 if x==0 \&\& y==0
              \form{ \overline{x \lor v}}
              \scriptsize{Just like with NAND, all functions} \\ \scriptsize{ can be made with NOR}}\\
              \hline
              \mc{\scriptsize{XOR: exclusive or} \\ 
              The XOR is true if only one input is true.\\
              \form{ x \oplus y} \\ 
              }\\
              \hline
              \mc{\scriptsize{Addition of bits.} \\ 
                \pic{220613-7}\\
                \scriptsize{\textcolor{Red}{AND signifies the overflow of bits. 1 0 <- 1 1}}\\
                \scriptsize{\textcolor{Red}{XOR signifies the addition of bits. 0 OR 1}}\\
              }\\
              \hline
              \mc{\scriptsize{Literal: variable or negation of variable: \(x_1 , \overline{x_2}\)}}\\
              \mc{\scriptsize{Conjunction-term: conjunction of literals \(x_1 x_2=x_1 \land x_2 \) }
              \vspace{-0.1in}}\\
              \mc{\scriptsize{Disjunction-term: disjunction of literals \(x_1 \lor x_2\)}}\\
              \mc{\scriptsize{Minterm: conjunction with ALL parameters of a function} 
              \vspace{-0.1in}}\\
              \mc{\scriptsize{Maxterm: disjunction with ALL parameters of a function}}\\
              \hline
              \mc{\scriptsize{Disjunctive Normalform DNF} \\ 
              \scriptsize{a disjunction of conjunctions. \(x_1 x_2 \lor \overline{x_1 x_2}\)}\\
              Functions are often displayed as DNF, since this format \\ requires only 3 symbols:
              \(\lor \land \lnot \) \\ 
              \scriptsize{The canonical DNF C-DNF: a DNF with all parameters} \\
              the canonical DNF is often used to display the true false table.\\
              The C-DNF is then often simplified to get the end result\\
              \pic{220613-8} \\ \pic{220613-9}\\
              note that DNF has nothing to do with the ferrari engine.\\
              }\\
              \hline
              \mc{logical function only return 1 or 0. In order to\\ return an entire number, we
              would have to map this function. \\ luckily there are several predefined mapped functions \\
              -- nor(x) invert all bits in x \\ 
              -- and(x,y) check the individual bits of x,y with and\\
              -- or(x,y) check the individual bits of x,y with or\\ 
              -- nor(x,y) check the individual bits of x,y with nor\\  
              }\\ 
              \hline
              \mc{\scriptsize{Bitwise operations in java...} \\ \pic{220613-10} \\
              \scriptsize{ || and \&\& are evaluations} \\ note that with || and \&\&, if the first
              evaluation is enough \\to determine the result, the second one won't be executed.\\
              a=False, b=True -> a \&\& b -> a is false, therefore result false.
              }\\
              \hline
              \mc{\scriptsize{Variable sizes in java} \\ \scriptsize{int = 32 bit} \\ 
              \scriptsize{short = 16 bit} \\ \scriptsize{byte = 8 bit} \\ \scriptsize{long 64 bit} \\
              Please note that these should only be used when, \\ you either save significant memory,
              or the integer isn't big enough.}\\
              \hline
              \mc{\scriptsize{multiplying a binary number} \\ 
              you have to multiply every single bit and add the corresponding 0s. \\ 
              \pic{220613-11} \\ 
              \pic{220613-12}
              }\\
              \hline
              \mc{\scriptsize{\textcolor{Red}{Multiplication with potences is just a leftshift!!}} \\
              \scriptsize{\textcolor{Red}{\(2^4 * 101 = \) add 4 0s to 101 -> 101'0000}}}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\scriptsize{\textcolor{Red}{Division with potences is a rightshift!!}} \\ 
              \scriptsize{\textcolor{Red}{\(\dfrac{1`0111}{2^3} =\) remove 3 bits from 1`0111 -> 101}}\\
              }\\
              \hline
              \mc{\scriptsize{Left \& Rightshift java} \\ 
                \scriptsize{logical right: a \r{> > >} x -> 101 \r{> > >} 1 -> 010}\\
                \scriptsize{logical left: a \r{< < <} x -> 101 \r{< < <} 2 -> 1`0100}\\
                \scriptsize{arithmic right: a \r{>>} x -> 101 \r{>>} 1 -> 110}\\
                \scriptsize{arithmic left: a \r{<<} x -> 101 \r{<<} 2 -> 1`0111}\\
                \scriptsize{the >>> and <<< add the MSB value instead of 0} \\
                \scriptsize{The reason for this is unsigned and signed!!}
              }\\
              \hline
              \mc{\scriptsize{Reading a bit} \\ \pic{220613-13}}\\
              \hline
              \mc{\scriptsize{Setting a bit} \\ \pic{220613-14}}\\
              \hline
              \mc{\scriptsize{Deleting a bit} \\ \pic{220613-15}}\\
              \hline
              \mc{\scriptsize{\r{Combine these with right and left shift!}} \\ 
                  \scriptsize{read: b \& (1 << n) >>> n} 000(b AND 11111...)\\
              \scriptsize{set: (b | (1 << n))} b OR 11111...\\
              \scriptsize{delete: b \& ~(1 << n)} b AND not 11111..\\
              \pic{220613-16}
              }\\
              \hline
              \mc{\footnotesize{Addition and Subtraction} \\ 
                \scriptsize{Addition: } \hspace{0.55in} \scriptsize{Subtraction: (Zweierkomplement)} \\
                \pic{220613-18} \pic{220613-19} \\ \pic{220613-20} \\
              }\\
              \hline
              \mc{\footnotesize{Signed \& Unsigned} }\\ 
              \mc{\scriptsize{Unsigned: only positive integers!}}\\
              \mc{\scriptsize{Signed: MSB 0 = positive, MSB 1 = negative }\\
              \scriptsize{the rest is a regular binary number.}\\
              note: This is something you simply need to know.\\ 
              It isn't included in some encoding!!\\
              \pic{220613-21} \\ \pic{220613-22} \\
              \scriptsize{note the difference in positive and negative} \\ 
              \scriptsize{in the signed category! size constraints!} \\ 
              \pic{220613-23} \\
              \scriptsize{Note -1 is 1111`1111. Negative numbers are}\\
              \scriptsize{calculated: 0 - number}\\
              This means an overflow on unsigned ints will lead \\ to it being 0 again.\\
              On signed ints, it will drop to negative maximum.\\
              \scriptsize{Special cases in signed:}\\
              \scriptsize{\(2^{n-1}\) max -> always negative as MSB = 1}\\
              \scriptsize{Max : 100000000...}\\
            \scriptsize{0 -> can't be negative as this bit is used for \(2^{n-1}\) }}\\
            \hline
              \mc{\scriptsize{Note that when increasing memory for signed values,} \\
              \scriptsize{you need to use the >> operators to copy the MSB.} \\
              \scriptsize{increasing memory for -1 -> 4 bit to 8 bit} \\ 
              \scriptsize{0000`1111 = 15 !! WRONG !! -> 1111`1111 = -1!!}\\
              }\\
              \hline
              \mc{\scriptsize{For signed left shift, check if you have spare memory} \\ 
              \scriptsize{left shift without checking might result in loss of MSB!}\\
              \scriptsize{4 bit max: 1001 < < < 2 = 0100 !! prefix changed !!}\\
              }\\
              \hline
              \mc{\scriptsize{multiplication: series of left shifts.} \\ 
              \mc{\scriptsize{1101 * 110 = 11`0100 + 1`1010 = 100`1110}\\
              10 -> add 1 zero, 100 -> add 2 zero, get the sum of both \\ 
              \scriptsize{Size increase: max double -> \(x^2\)}  \\
              110 * 110 -> 1100 + 1`1000 = 11`1000 (3 to 6 bits) \\
            }\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{\pic{220613-28} \\ \scriptsize{Note that we don't need to care about signed, if } \\
              \scriptsize{we do not overwrite the MSB!}}\\
              \hline
              \mc{\scriptsize{Division} \\ 
              should be avoided, slow operation compared to others \\ 
              32 bit -> 20 times as long as multiplication \\ 
              64 bit -> 80 times as long as multiplication \\ 
              -- can be replaced with right shift for potences \\ see /10 for decimal numbers.\\
              signed and unsigned division are completely different \\
              \pic{220613-29}
            }\\
              \hline
              \mc{\footnotesize{Inversion} \\ 
                \form{N(b+1) > 2^n - 1 - b > 2^n == 0}
                \form{0-1 = -1 > 11111... > -1 - b = \overline{b}}\\
                Okay, the idea is that -1 is the number with all bits set to 1 \\
                This means that no matter what you do, you can't have overflow.\\
                In fact this means that b can be inverted by subtracting it to -1.\\
                \pic{220613-24}
              }\\
              \hline
              \mc{\scriptsize{Unsigned in java} \\
              You can't declare unsigned integer etc, instead you just use the \\ 
              unsigned functions. \\
              \pic{220613-25}}\\
              \hline
              \mc{\scriptsize{Java comparators} \\ \pic{220613-26}}\\
              \hline
              \mc{Beause processors are super fast in addition an subtraction, \\
              we can simplify equality checks by using these 2 operations.\\
              -- example unsigned, check if a < b: \\ \pic{220613-26} \\
              c is the carry bit, and it is only set to 1 if a < b!!\\
              -- example signed: \\ \pic{220613-27}\\
              -- the check for all 0 or 1 is also fast -> AND...\\
              In java we only work with the signed interpretation by default \\ 
              use the before mentioned special functions for unsigned!\\
              }\\
              \hline
              \mc{}\\
              \hline
              \mc{}\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{tiny}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{}\\
              \hline
            \end{tabular}
            \hspace{-0.07in}
            \begin{tabular}[t]{@{\hskip1pt}p{6.9cm}|}
              \hline
              \mc{}\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{tiny}
    \end{table}
\end{document}
