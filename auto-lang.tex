\documentclass{article}
\usepackage[left=-1.5mm, right=-1.5mm, top=-1mm, bottom=-1.5mm]{geometry}
\usepackage[document]{ragged2e}
\usepackage{graphicx}
\usepackage{pict2e}
\usepackage{amsmath, mathtools, nccmath, amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage{array, makecell}
\usepackage{moresize}
\usepackage[T1]{fontenc}
\usepackage{noto-sans}
\renewcommand\cellalign{cl}
\renewcommand\theadalign{lc}
\newcommand{\ns}{\\ \vspace{-0.03in}}
\newcommand{\mc}[1]{\makecell[cl]{#1}}
\newcommand{\mcc}{\makecell[{{c}}]}
\newcommand{\mcr}{\makecell[{{r}}]}
\newcommand{\pic}{\includegraphics[scale=0.3]}
\newcommand{\form}[1]{\vspace{-0.03in}\\ \small{\textcolor{Red}{\(#1\)}} \\ \vspace{-0.03in}}
\newcommand{\forms}[1]{\vspace{-0.01in}\\ \scriptsize{\textcolor{Red}{\(#1\)}\\ \vspace{-0.01in}}}
\newcommand{\noskipform}[1]{\small{\textcolor{Red}{\(#1\)}}}
\newcommand{\fpic}{\vspace{-0.05in} \\ \includegraphics[scale=0.3]}
\newcommand{\dx}[1]{\scriptsize{\textcolor{Red}{\(\dfrac{d}{dx}#1\)}}}
\newcommand{\dxs}[1]{\ssmall{\(\dfrac{d}{dx}#1\)}}
\newcommand{\dxo}{\dfrac{d}{dx}}
\newcommand{\hs}{\hspace{0.5in}}
\renewcommand{\b}{\textbf}
\renewcommand{\r}[1]{\textcolor{Red}{#1}}
\newcommand{\blu}[1]{\textcolor{Blue}{#1}}
\newcommand{\gre}[1]{\textcolor{Green}{#1}}
\newcommand{\yel}[1]{\textcolor{Yellow}{#1}}
\newcommand{\ora}[1]{\textcolor{Orange}{#1}}
\newcommand{\lims}[1]{\lim\limits_{#1}}
\newcommand{\atb}[1]{\int_a^b #1 \,dx}
%\renewcommand{\arraystretch}{1.5}
\graphicspath{{./Pictures/}}
\makeatletter
\DeclareRobustCommand{\bigplus}{%
  \mathop{\vphantom{\sum}\mathpalette\@bigplus\relax}\slimits@
}
\newcommand{\@bigplus}[2]{\smash{\vcenter{\hbox{\make@bigplus{#1}}}}}
\newcommand{\make@bigplus}[1]{%
  \sbox\z@{$\m@th#1\sum$}%
  \setlength{\unitlength}{\wd\z@}%
  \begin{picture}(1.4,1.4)
  %\roundcap
  \linethickness{.17ex}
  \Line(.7,.14)(.7,1.26)
  \Line(.14,.7)(1.26,.7)
  \end{picture}%
}
\DeclareRobustCommand{\bigtimes}{%
  \mathop{\vphantom{\sum}\mathpalette\@bigtimes\relax}\slimits@
}
\newcommand{\@bigtimes}[2]{\vcenter{\hbox{\make@bigtimes{#1}}}}
\newcommand{\make@bigtimes}[1]{%
  \sbox\z@{$\m@th#1\sum$}%
  \setlength{\unitlength}{\wd\z@}%
  \begin{picture}(1,1)
  %\roundcap
  \linethickness{.17ex}
  \Line(.1,.1)(.9,.9)
  \Line(.1,.9)(.9,.1)
  \end{picture}%
}
\makeatother
\begin{document}
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{cc}
          \begin{tabular}[t]{|@{\hskip1pt}p{10.475cm}|}
              \hline
              \mc{\r{Predicate:}\\ 
              a mathematical predicate can be True or False.\\
              predicates are functions with boolean return values:\\
              P, Q(n), R(x,y,z)
              }\\
              \hline
              \mc{\r{Logical Operators:}\\
              AND: \(P \land Q\) || OR: \(P \lor Q\) || NOT: \(\lnot P\)  \\ 
              Implication: \(P \implies Q = \lnot P \lor Q\)\\
              }\\
              \hline
              \mc{\r{Distributive Rule}\\
              \(P \land (Q \lor R) = (P \land Q) \lor (P \land R)\)\\
              \( P \lor (Q \land R) = (P \lor Q) \land (P \lor R) \)\\
              }\\
              \hline
              \mc{\begin{tabular}{ll}
              \mc{\hspace{-0.08in}\r{De Morgans Law}\\
              \(\lnot (P \land Q) = \lnot P \lor \lnot Q\)\\
              \(\lnot (P \lor Q) = \lnot Q \implies \lnot P\)\\
              \(P \implies Q = \lnot Q \implies \lnot P\)\\
            }\hspace{-0.09in} & \vline 
              \mc{\r{Implication}\\
                \(P \implies Q = True\) \& \(\lnot P \implies Q = True\)\\
              \(P \implies \lnot Q = False\) \\
              \(\lnot P \implies \lnot Q = True\)
              }
              \end{tabular}
              }\\
              \hline
              \mc{\r{Quantors}\\
              \begin{tabular}{cc}
              \mc{\r{OR:} \( \bigvee_{k=0}^n P_k\)\\
              P true for any \(k \in {0 .. n}\)}&
              \mc{\r{AND:} \(\bigwedge_{k=0}^n P_k\)\\
              P true for all \(k \in n\)}\\
              \mc{\r{All:} \(\forall k \in {0 .. n} = P_k \)\\
              for all k P = True}&
              \mc{\r{Exists:} \(\exists k \in {0 .. n} = P_k\)\\
              a k exists where P = True
              }\\
              \end{tabular}
              }\\
              \hline
              \mc{\r{Normalforms}\\
              \begin{tabular}{cc}
              \mc{\r{disjunctive}\\
              \((x1 \land x2 ) \lor (\overline{x1} \land x2) \lor (x1 \land \overline{x2})\)
              }&
              \mc{\r{conjunctive}\\
              \((x1 \lor x2) \land (\overline{x1} \lor x2) \land (x1 \lor \overline{x2})\)
              }\\
              \end{tabular}\\
              \footnotesize{These are useful for true and false tables}\\
              \footnotesize{This one would result to true if x1 or x2 is true.}\\
              }\\
              \hline
              \mc{\r{Quantities:}\\
              \(\emptyset = \{\}\) \hs \([n] = \{0 .. n\}\) \hs \{a .. z\}\\
              \begin{tabular}{ll}
                \mc{\r{Union:}\\ \(A \cup B = \{x | x \in A \lor x \in B\}\)} &
                \mc{\r{Intersection:}\\ \(A \cap B = \{x | x \in A \land x \in B\}\)}\\
                \mc{\r{Complement:} \\ \(\overline{A} = \{x | x \notin A\}\)}&
                \mc{\r{Difference:} \\ \(A \setminus B = \{x \in A | x \notin B\}\)}
              \end{tabular}
              }\\
              \hline
              \mc{\r{Pairs}
                \(A \times B = \{(a,b) | a \in A \land b \in B\}\)
              }\\
              \hline
              \mc{\r{n-Tuples}
              \(\bigtimes_{k=0}^n A_i = \{(a_o,a_i,..,a_n)| a_i \in A_i \}\)
              }\\
              \hline
              \mc{
              \r{Undirected Graph}\\ \footnotesize{doesn't have directions, and therefore can't have edges to itself}\\
              \r{Directed Graph} \\ \footnotesize{This does have directions, therefore an edge to itself is valid!}\\
              \pic{220617-4}\\
              Vertices V = \(\{v_1,v_2,...,v_n \}\) Edge e = \(\{v_3,v_4\}\) \\
              EdgeCount E = \(\{e | e Edge \}\)\\
              }\\
              \hline
              \mc{\r{Proofs:}\\
              \r{constructive Proof (proof by reforming)}\\
              \footnotesize{Consider \(ax^2 + bx + c = 0\), we can proof this to have 2 solutions by reforming.}\\
              \pic{220617-5}\\
              \footnotesize{If \(b^2 - 4ac > 0\) then we have 2 solutions!}\\
              \r{Proof by contradiction}\\
              \footnotesize{Take -2, it isn't a natural number. We can prove this by claiming the opposite.}\\
              \footnotesize{If -2 is a natural number, then it has all the attributes of a natural number.}\\
              \footnotesize{For example, it should be possible to take the square root of -2.}\\
              \(\sqrt{-2} = NaN\)\\
              \footnotesize{As you can see -2 does not have this attribute and is therefore}\\
              \footnotesize{NOT a natural number!}\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.475cm}|}
              \hline
              \mc{\r{Proof by Induction}\\
              \footnotesize{This is particularly useful if you want to check an attribute}\\
              \footnotesize{for a range of numbers such as n or n+1}\\
              \begin{tabular}{ll}
              \mc{\footnotesize{Base claim:}\\
              \(P(n) = \sum_{k=1}^n = \dfrac{n(n+1)}{2}\)\\
              \footnotesize{Anker: check for n=1}\\
              \(P(1) = \dfrac{1(1+1)}{2} = 1\)\\}&
              \mc{\footnotesize{Hypothesis: it also works for n+1}\\
              \pic{220617-6}}\\
              \end{tabular}
              }\\
              \hline
              \mc{\r{Alphabet and Word}\\
              \(\Sigma\) = Alphabet: Nonempty Quantity of characters\\
              \(\Sigma^n = \Sigma \times ... \times \Sigma\) = String\\
              \( w \in \Sigma^n\) An element in that string is a Word with length n. \\
              \r{\(\varepsilon \in \Sigma^0\) The empty word, don't forget the empty word!}\\
              Quantity of all words:\\
              \(\Sigma^* = \{\varepsilon\} \cup \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup ... = \bigcup_{k=0}^\infty \Sigma^k\)\\
              }\\
              \hline
              \mc{\r{Language}
              \r{\(L \subset \Sigma^* \) = Language}\\
              \(L= \emptyset \subset \Sigma^* =\) Empty Language\\
              \(L = \Sigma^* \to \Sigma = \{0,1\}\) all binary strings.\\
              \r{A language is regular if a DFA can be formed out of it.}
              }\\
              \hline
              \mc{\r{Deterministic Finite Automaton (DFA/DEA)}\\
              \pic{220617-7}\\
              \footnotesize{A very simple machine that accepts a variety of inputs.}\\
              \footnotesize{Only requirement is that a D follows after T.}\\
              \footnotesize{This means all the following inputs are valid:}\\
              \footnotesize{\_ (empty word!), D, DD, TD, TTTTTTTD, DDDDDTD, DDDDD, ....}\\
              \begin{tabular}{ll}
              \mc{\pic{220617-8}} &
              \mc{Machine A: \{\r{Q},\blu{\(\Sigma\)},\gre{\(\delta\)},\(q_0\),\yel{F}\}\\
              State = \r{Q} -> \(\{q_1,q_2,...,q_n\}\)\\
              Alphabet = \blu{\(\Sigma\)}\\
              Transitioning-Function = \(\gre{\delta} : \r{Q} \times \blu{\Sigma} \to \r{Q}\)\\
              Starting State = \(q_0 = L(\varepsilon) = L\)\\
              Acceptable Endstates =\(\yel{F} \subset \r{Q}\)
              }\\
              \end{tabular}\\
              \pic{220617-9}\\
              \r{Language of DFA A:}\\
              \r{\(L(A) = \{ w \in \Sigma^* | A \text{ accepts } w \} = \{w \in \Sigma^* | \delta(q_0,w) \in F\}\)}\\
              \footnotesize{The language of a DFA is simply all accepted words!}\\\\
              \r{Error States in DFA}\\
              \pic{220617-10}\\
              \begin{tabular}{ll}
              \mc{\pic{220617-11}\\}&
              \mc{\footnotesize{from q, many paths lead to F}\\
                \footnotesize{This means 11, or 0 would be the "same"}\\
                \footnotesize{\(L(q) = \{0,10,11,12,...\} \)}\\
                \footnotesize{The same would obviously apply to P}
              }\\
              \end{tabular}
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{cc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.475cm}|}
              \hline
              \mc{\r{Myhill-Nerode}\\
              \footnotesize{Adding a word to a word, to make it compatible with a language}\\
              \r{\(L(w) = \{w' | ww' \in L\} \text{ including: } L(\varepsilon)\)!}\\
              \begin{tabular}{ll}
                \mc{\pic{220617-12}\\} &
                \mc{\footnotesize{even and uneven amounts of 0s}\\
                \footnotesize{mod 2 zero's, 1's don't matter}\\
                }\\
              \end{tabular}\\
              \r{Detecting Nonregular Languages with Myhill}\\
              \footnotesize{The examples before always had a specific amount of words/characters}\\
              \footnotesize{that one had to add, in order to accept the word.}\\
              \footnotesize{However, there are languages that would need infinite states}\\
              \footnotesize{in order to find the entire language of a DFA}\\
              \footnotesize{A good example for this is the language \(1^n0^n\)}\\
              \begin{tabular}{ll}
              \hspace{-0.1in} \mc{\pic{220617-13}} &
              \mc{\footnotesize{for every 0 that we add, we need a 1} \\ 
              \footnotesize{this means that for n+k 0's we need k 1's}\\
              \footnotesize{as \(\lim_{k\to\infty}\) we need \(\infty \) states!}\\
              \footnotesize{not possible with a \r{Deterministic} automaton!}\\\\
              \footnotesize{also note: we have clear error states}\\
              \footnotesize{anything starting with 1 is an error.}
              }\\
              \end{tabular}
            }\\
              \hline
              \mc{\r{Differentiation of States}\\
              \footnotesize{To get a minimal DFA, we eliminate all states that are superfluous.}\\
              \pic{220617-14}\\
              \footnotesize{Here the 3 acceptable states can be put together, they are the same!}\\
              \begin{tabular}{ll}
              \mc{\pic{220617-15}}&
              \mc{\pic{220617-16}\\
              \footnotesize{z1 and z2 are the same!}\\
              \footnotesize{they can't be differntiated}\\
              \pic{220617-17} \\
              \footnotesize{New minimal Automaton!}\\
              }\\
              \end{tabular}\\
              \footnotesize{This algorithm makes it easy to see whether or not states are the same!}\\
              \pic{220617-18}\\
              }\\
              \hline
              \mc{\r{Beauty of a language / Pumping Lemma}\\
              \footnotesize{a language L can be pumped if the following is valid:}\\
              \(\exists N > 0 \text{ where } w \in L \land |w| \geq N\)\\
              \footnotesize{If this word can be divided into 3 parts x,y,z while:}\\
              \(|xy| \leq N \land |y| > 0 \land |x| \geq 0 \land |z| \geq 0\land xy^kz \in L \to \forall k \in \mathbb{N}\)\\
              \footnotesize{Find a number N that is bigger than 0 but less than the length of xy}\\
              \footnotesize{while the length of y is greater than 0 and \(xy^kz\) is still part of the language}\\
              \footnotesize{\r{Note: The power of \(xy^kz\) is NOT a power, but an indicator how many y's!!!}}\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.475cm}|}
              \hline
              \mc{\footnotesize{\r{Any language that can be pumped is a regular language, and is therefore "schÃ¶n"}}\\
                \footnotesize{Consider the following 2 examples:}\\
                \begin{tabular}{ll}
                  \hspace{-0.12in}
                  \mc{\( L(s1) = \{ 0,1| \text{ending with 1}\} \)\\
                \footnotesize{z = 1, xy = any combination of 1 and 0}\\
                \footnotesize{try: x=0 y=1010111 z=1,True -> \(N \geq 7\)}\\
                \footnotesize{try: x=0 y=1 z=1,True -> \(N \geq 1\)}\\
                \footnotesize{This can be done with any y, x}\\
                \footnotesize{It will always satisfy all requierements}\\
                \footnotesize{of the pumping lemma.}\\
                \footnotesize{this language is regular.}
              }& \hspace{-0.05in}
                \mc{\( L(s1) = \{ 0^n,1^n| n \geq 0\} \)\\
                \footnotesize{if z=1, more 1's than 0's, FALSE}\\
                \footnotesize{if x - 0, more 0's than 1's, FALSE}\\
                \footnotesize{This means we need x=0, z=0}\\
                \footnotesize{If we do that, then y is empty}\\
                \footnotesize{No matter what we do, it is FALSE}\\
                \footnotesize{\(0^n1^n\) is therefore not regular}}\\
                \end{tabular}\\
                \pic{220617-19}\\
              }\\
              \hline
              \mc{\r{Pumping Lemma usage guide !!FOLLOW THIS!!}\\
              1. Claim that L is regular\\
              2. According to pumping lemma \(\exists N\)\\
              \footnotesize{Don't make claims about the size of N!}\\
              3. Choose a word \(w \in L | |w| \geq N\)\\
              \footnotesize{Definition with N has to be written!}\\
              4. Division into parts according to Pumping Lemma\\
              \footnotesize{\(w = xyz, |xy| \leq N, |y| > 0\) ,etc}\\
              5. Check if word is in language\\
              \footnotesize{min 1 word not in language: \(xy^kz \notin L | k \in \mathbb{N}\)}\\
              \footnotesize{Explain why this word is not in the language}\\
              6. Contradiction, aka explain that this language is not regular.\\
              }\\
              \hline
              \mc{\r{Non-Deterministic Finite Automaton (NFA / NEA)}\\
              \footnotesize{Before every step was clear, there was no other determinism}\\
              \footnotesize{other than the input and the current state. A non-deterministic automaton}\\
              \footnotesize{Can have other things, like only accept the last 2 0's}\\
              \footnotesize{This is illustrated as both a DFA and an NFA:}\\
              \begin{tabular}{ll}
              \mc{\pic{220617-20}}&
              \mc{\footnotesize{Both have the same goal, only the last}\\
                \footnotesize{2 zero's lead to the acceptance state.}\\
                \footnotesize{However one is obviously easier, while}\\
                \footnotesize{not giving clear info on in what state it is,}\\
                \footnotesize{it is hence non-deterministic.}\\
              }\\
              \end{tabular}\\
              \r{Formal Definition:}\\
              \begin{tabular}{ll}
              \mc{\pic{220617-21}} &
              \mc{Machine A: \{\r{Q},\blu{\(\Sigma\)},\gre{\(\delta\)},\(q_0\),\yel{F}\}\\
              State = \r{Q} -> \(\{q_1,q_2,...,q_n\}\)\\
              Alphabet = \blu{\(\Sigma\)}\\
              Transitioning-Function = \(\gre{\delta} : \r{Q} \times \blu{\Sigma} \to \b{\r{P(Q)}}\)\\
              Starting State = \(q_0 = L(\varepsilon) = L\)\\
              Acceptable Endstates =\(\yel{F} \subset \r{Q}\)
              }\\
              \end{tabular}\\
              \r{P(Q) is the Potence Quantity!!}\\
              \r{Note the P(Q), it means that we have more complex transitions!}\\
              \footnotesize{no arrow, multiple arrows for a certain character. See b in example}\\
              \footnotesize{General tipp for NFA, only write what you need to accept the word!}\\
              }\\
              \hline
              \mc{\r{NFA To DFA}\\
              \pic{220617-22}\\
              \(\overline q_1\) is the complement Quantity. It means, any state other than \(q_1\)\\
              Q is the full Quantity, in here the NFA can be in any state.\\
              \(\emptyset\) is the error state.\\
                            }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \clearpage
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{cc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.475cm}|}
              \hline
              \mc{\r{Formal Definition of the Transition}\\
              DFA is marked with ', the regular expression is for NFA\\
              Given \(\delta\) of an NFA and Transitions \(M \subset Q\)\\
              \(\delta' : Q \times \Sigma \to P(Q): (M,a) \mapsto \delta ' (M,a) = \bigcup_{q\in M} \delta (q,a) \)\\
              \(Q' = P(Q)\)\\
              \(\Sigma' = \Sigma\)\\
              \(q_0' = \{q_0\}\)\\
              \(F' = \{M \in P(Q) | F \cap M \neq \emptyset \}\)\\
              M is the union of all possible endstates.\\
              \footnotesize{Note: a Thompson NFA needs at least 1 acceptable endstate!}\\
}\\
              \hline
              \mc{\r{\(\varepsilon\) Transitions in NFA's}\\
              \begin{tabular}{ll}
                \mc{\pic{220617-23}}&
                \mc{\(\delta : Q \times (\Sigma \cup \{\varepsilon\}) \to P(Q)\)\\
                This means that \(\varepsilon\) signifies a transition\\
              without using a character!!}\\
              \end{tabular}
              }\\
              \hline
              \mc{\r{Conversion from \(\varepsilon\)-NFA to regular NFA}\\
              Any \(\varepsilon\)-NFA can be converted to a regular NFA!\\
              \(E(q) =\)Quantity of all \(\varepsilon\)-Transitions from q\\
              \(E(M) = \cup_{q\in M}E(q)\) Quantity of all \(\varepsilon\)-Transitions\\
              \(\delta = Q \times (\Sigma \cap \{\varepsilon\} \to P(Q): (q,a) \mapsto E(\delta(q,a)))\)\\
              \r{\(\varepsilon\)-NFA to DFA:}\\
              \pic{220617-24}\\
            }\\
              \hline
              \mc{\r{Set-Operations with Automatons}\\
                \pic{220617-26}\\
              }\\
              \hline
              \mc{}\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.475cm}|}
              \hline
              \mc{\r{Pump-able, but not regular}\\
              \pic{220617-28}\\
              The first part L1 is regular, but the second isn't\\
              The only way we can figure that out is by using the Myhill method!\\
              Because L2 is not regular, the composite Language L is not regular\\
              }\\
              \hline
              \mc{\r{Regular Operations}\\
                \pic{220617-27}\\
              }\\
              \hline
              \mc{\r{Regular Expressions}\\
              \pic{220617-29}\\
              \pic{220617-32}\\
              \r{There is a DFA for every regular expression!}\\
              }\\
              \hline
              \mc{\r{VNEA / VNFA to regular expression}\\
              1. add a new start and stop state. This is required as\\
              the regular expressions can't have arrow back to the origin.\\
              \pic{220618-1}\\
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
          \vfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
      \vspace{-0.01in}
        \begin{normalsize}
          \begin{tabular}{cc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.475cm}|}
              \hline
              \mc{\vspace{0.01in}\\
              \pic{220618-2}\\
              \pic{220618-3}}\\
              \hline
              \mc{\r{Contextfree-Grammar (CFG) >> \(G=(V,\Sigma,R,S)\)}\\
                \begin{tabular}{ll}
              \makecell[l]{
              \(V\): Variables / Non-Terminalsymbols\\
              \(\Sigma\): Terminalsymbols (Alphabet)\\
              \(R\): Rules of Form \(A -> x_1X2...x_n \)\\
              \(\text{ with } A \in V, x_i \in V \cup \Sigma\)\\
              \(S\): Starvariable\\
              \r{Rule A -> w generated out of uAv}\\\r{
              \(uwv: uAv \implies uwv\)}\\
              derivate v from u:\\
              \(u \Rightarrow u_1 \Rightarrow u_2 \Rightarrow ... \Rightarrow u_n \Rightarrow v \text{ or } u \Rightarrow^* v\)\\
              Context free grammar generated from G:\\
              \(L(G) = \{w \in \Sigma^* | S \Rightarrow^* w \}\)
            }& \hspace{-0.15in}
              \makecell[l]{\pic{220618-4}}\\
              %\hline
              Example:\\
              \mc{\r{Grammar \(L = \{0^n1^n | n \geq 0\}\)}\\
              Variables: \(V = \{S\}\)\\
              Terminalsymbols: \(\Sigma = \{0,1\}\)\\
              Rules: \(R = \{S \to \varepsilon | 0S1\}\)\\
              Startvariable: \(S\)\\
              }&
              \mc{\pic{220618-5}}\\
              \end{tabular}\\
              \r{Contextfree-Grammar Term explanations}\\
              \footnotesize{\r{Terminalsymbols: }}\footnotesize{Symbols that we can't translate further, aka they are terminal.}\\
              \footnotesize{\r{CFL = Contextfree-Language}}\\
              \footnotesize{\r{\(\Rightarrow^*\)} means can be derived from}\\
              \footnotesize{\(uAv \Rightarrow^* uwv\): all words that can be made with uAv}\\
              \footnotesize{\blu{The goal of this grammar is to only have terminal symbols in the end}}\\
              \footnotesize{\blu{Aka we remove the variables one by one, via these rules}}\\
              }\\
              \hline
              \mc{\r{Definition of Context-free}\\
              \footnotesize{The context is only based on the input variable.}\\
              \footnotesize{Take A as a variable, if it can be parsed wihout regard for}\\
              \footnotesize{what is to the left or right of it, then it has a context free rule}\\
              \(A \to \text{something}\)\\
              \footnotesize{A grammer with only variables like A is considered context free.}\\
              \pic{220618-6}\\
              This means that something like: \(S = aAb\)\\
              Turns into this: \(S \to aAb \to aab\)\\
              The A can be replaced without regard for context,\\
              S is therefore context free.\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.475cm}|}
              \hline
              \mc{\r{Multiple Contextfree-Grammars}\\
              Context-free grammars can be interpreted in multiple ways:\\
              This means there is no definite way to interpret something like:\\
              \(0^n1^n\)\\
              \pic{220618-7}\\
              The grammar \(G_2\) gives us a clear Parse-tree, the first one doesn't\\
              The reason for this is the obvious haskell like structure on the right.\\
              The one on the left has no idea of leafs and nodes.\\
              Another example with parse trees:\\
              \pic{220618-8}\\
              \pic{220618-9}
              }\\
              \hline
              \mc{\r{Facts about Contextfree-Grammar:}\\
              -- Contextfree-Grammars can't be compared!\\
              -- Only the \(L_1 \cup L_2\) Quantity operation can be done\\
              \,\,\, On ANY Contextfree-Grammar\\
              -- The amount of steps to derive a word is not always clear\\
              \,\,\, Some Grammars allow this, some don't\\
              -- the class of regular languages is complete with regular operations
              }\\
              \hline
              \mc{\r{Regular Operations on Contextfree-Grammar}\\
              \pic{220618-10}
              }\\
              \hline
              \mc{\r{Stack Automaton}\\
              \pic{220618-11}\\
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table*}[htbp]
    \vspace{-0.1in}
        \begin{normalsize}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\pic{220618-12}\\
              \pic{220618-13}\\
              \pic{220618-14}\\
              }\\
              \hline
              \mc{\r{Chomsky-Normalform}\\
              This is used to make sure, that we don't have needless Variables\\
              \pic{220618-15}\\
              In order to solve this, we need to follow these rules:\\
              \r{1. No Unit Rules: \(A \to B\)}\\
              \r{2. No Rules like: \(A \to \varepsilon\) unless necessary: \(S \to \varepsilon\)}\\
              \r{3. Right side has exactly 2 Variables, or 1 terminalsymbol.}\\
              \r{\,  \,\,  Everything else if forbidden on the right side.}\\
              \footnotesize{Note this includes ANY other formation, including \(aB,aa,ABC,aAB\)}\\\\
              \r{Transforming into Chomsky-Normalform}\\
              \pic{220618-16}\\
              In-depth explanation:\\
              \pic{220618-17}\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\pic{220618-18}\\}\\
              \hline
              \mc{\r{Usage of Chomsky-Normalform Grammar G}\\
              The derivation of a word \(w \in L(G)\) is always possible\\
              within \(2* |w| - 1\) Rule applications.\\
              Reason:\\
              \r{1. Apply \(|w| - 1\) Rules of form \(A \to BC\) to generate a word}\\
              \r{\,  \,\, with length \(|w|\) out of \(S\).}\\
              \r{2. Apply \(|w|\) Rules of form \(A \to a\) to generate the word \(w\)}\\
              This is a total of \(2 * |w| -1\) Rule applications
              }\\
              \hline
              \mc{\r{Deterministic Parsing \ CYK-Algorithm}\\
              Deterministic Parsing is used to check if a word can be derived\\
              from either S, aka the entire Grammar\(S \Rightarrow^* w\),\\
              or just a variable of it for example A. \(S \Rightarrow^* w | A \in V\)\\
              This is especially easy with the Chomsky-Normalform!!\\
              \pic{220618-19}\\
              \pic{220618-20}
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table*}
    \pagebreak
    \begin{table}[ht!]
    \vspace{-0.1in}
        \begin{normalsize}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{Performance Comparison NFA/DFA}\\
              \pic{220618-21}\\
              }\\
              \hline
              \mc{\r{Standardization of Stack Automatons (PDA to CFG)}\\
                \footnotesize{PDA, Push-Down-Automaton = Stack Automaton}\\
                \footnotesize{The idea is to check whether or not Contextfree-Grammar can be expressed }\\
                \footnotesize{ using only regular expressions.}\\
                \footnotesize{One way of trying this is to create a Stack Automaton, }\\
                \footnotesize{that is based on such expressions.}\\
                \footnotesize{first need a Variable that handles words from input to stack \(A_{pq} \)}\\
                \footnotesize{Then we need rules for this \(A_{pq}\to A_{pr}A_{rq}\)}\\
                \footnotesize{from p to r and from r to q.}\\
                \footnotesize{\r{Note that \(A_{pq}\) signifies the amount of words that lead from p to q}}\\
                \footnotesize{\r{However, this is only the case because it is implied in the name,}}\\
                \footnotesize{\r{it is otherwise just a Non-Terminalsymbol!!!}}\\
                Turning the regular Stack Automaton to a CFG:\\
                \pic{220618-22}\\
                \pic{220618-23}\\
                \pic{220618-24}
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{Derived Rules from the Automaton:\\
              \pic{220618-25}\\
              \pic{220618-26}\\
              \r{every CFG can be converted to a Stack Automaton.}\\
              }\\
              \hline
              \mc{\r{Regularity Check for CFG / Pumping Lemma for CFG}\\
              \pic{220618-27}\\
              \pic{220618-28}\\
              \footnotesize{increasing a and b leads to c being smaller!}\\
              \footnotesize{increasing b and c leads to a being smaller!}\\
              \footnotesize{even if you increase ALL of them, you still have aa...(your pump)..bb}\\
              \footnotesize{which is NOT correct!}\\
              }\\
              \hline
              \mc{\r{Bakus-Naur Form}\\
                \footnotesize{-Naur is a machine specification for Rules of a CFG.}\\
              -- Variables: <variable-name>\\
              -- single Symbols: A\\
              -- Strings: 'Example'\\
              -- Rules: <variable-name> ::= expression\\
              \footnotesize{Haskell says hello!}\\
            \footnotesize{Expressions are a series of variables, single symbols or strings, separated by '|'}\\
              \pic{220618-29}
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{Extended-Backus-Naur-Form EBNF}\\
              -- Literals: "" or ''\\
              -- Rules are annotated with = instead of ::=\\
              -- Variables without <> and can include symbols\\
              -- comma for chaining: term, "*", expression\\
              -- semicolon for end, just like cpp: ;\\
              -- Comments: (* ... *)\\
              -- Optional recursion: \{...\}\\
              -- Option: []
              -- Groups: (...)\\
              -- Exception: - (without, not error handling)\\
              \pic{220618-30}\\
              \footnotesize{Both of these Naur implementations do of course resemble this:}\\
              \pic{220618-31}\\
              \footnotesize{One small problem with all this, these specifications change often}\\
              \footnotesize{So even EBNF is likely soon to be out-of-date....}\\
              \r{Note, EBNF does NOT save you from misimplementing things!}\\
              \pic{220618-32}\\
              \footnotesize{In this picture the Operator-prioritization was not implemented!}\\
              \footnotesize{This means this implementation is not correct, it calculates trash!}\\
              }\\
              \hline
              \mc{\r{The stack problem}\\
              The stack has enabled us to understand the Language \(0^n1^n\)\\
              However the language \(a^nb^nc^n\) remains uninterpretable.\\
              This can be solved by extending the stack.\\
              One idea is to double the stack, giving us access to every element\\
              The only problem is that this is a slow and tedious process.\\
              \r{This is where a turing machine comes into play with it's band!!}\\
              }\\
              \hline
              \mc{\r{Turing Machine (TM)}\\
              \pic{220618-33}\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{
                \r{Definition Of Deterministic Turing Machine}\\
              \begin{tabular}{ll}
                \mc{Turing Machine \\
                \(M = ( \)\r{\(Q\)}\(,\)\blu{\(\Sigma\)}\(, \Gamma,\) \gre{\(\delta\)}\(, q_0, q_{\text{accept}, q_{reject}})\)\\ 
                \textbullet \r{\(Q\)} : States\\
                \textbullet \blu{\(\Sigma\)} : Alphabet\\
                \textbullet \(\Gamma\) : Band-Alphabet: \(\text{\textvisiblespace{}} \in \Gamma \text{\textbackslash{}} \)\blu{\(\Sigma\)}\\
                \textbullet \gre{\(\delta\)} : \r{\(Q\)}\( \times \Gamma \to \) \r{\(Q\)}\( \times \Gamma \times \{L,R\}\)\\
                \textbullet \(q_0 \in \) \r{\(Q\)}: Startstate\\
                \textbullet \(q_{accept} \in \)\r{\(Q\)}: accepting state\\
                \textbullet \(q_{reject} \in \)\r{\(Q\)}: rejecting state\\
                }&
              \mc{\pic{220618-34}}\\
              \end{tabular}\\
              \pic{220618-35}\\
              \pic{220618-36}
              }\\
              \hline
              \mc{\r{\(a^nb^nc^n\)}\\
                \footnotesize{Before we asked the quetion of how we could create a Turing Machine,}\\
                \footnotesize{that understands the language \(a^nb^nc^n\)}\\
                \footnotesize{Is this already possible ? YES!}\\
                \pic{220618-37}\\
              }\\
              \mc{\r{Turing Machine Variants}\\
              \pic{220618-38}\\
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{
              \pic{220618-39}\\
              }\\
              \hline
              \mc{\r{Counter for TM}\\
              A language of a Turing Machine is countable\\
              \footnotesize{It essentially allows you to see all possible words.}\\
              \pic{220618-40}\\
              }\\
              \hline
              \mc{\r{Definitions for Computability (Entscheidbarkeit)}\\
                \pic{220618-42}\\
              }\\
              \hline
              \mc{\r{There are clear definite problems that we can solve:}\\
              \pic{220618-41}
              }\\
              \hline
              \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{And there are some that we can't solve:}\\
              \pic{220618-43}\\
              }\\
              \mc{\r{Halting Problem}\\
              \footnotesize{The idea is that we have a Decider H and a program D that always returns the oppsite.}\\
              \footnotesize{This D encompasses H, which means we give input to D, which gives the input to H}\\
              \footnotesize{Then H returns and D inverts it, as described above.}\\
              \footnotesize{The contradiction arises when you give D its own code as the input.}\\
              \footnotesize{\r{D passes this on and returns an answer, but D inverts it, aka does the opposite}}\\
              \footnotesize{This means H was wrong, aka the decider has lied, D didn't do what it said!}
              }\\
              \hline
              \mc{\r{Reduction}\\
              \pic{220618-44}\\
              \pic{220618-45}\\
              \pic{220619-1}\\
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{The law of Rice}\\
              \pic{220619-2}\\
              \pic{220619-3}\\
              }\\
              \hline
              \mc{\r{Overview of Computability}\\
              \pic{220619-4}\\
              }\\
              \hline
              \mc{\r{Efficiency and Computability}\\
              \footnotesize{We do not just have to ask ourselves whether or not the problem is solvable,}\\
              \footnotesize{but also whether or not we can do so in a sensible amount of time.}\\
              \footnotesize{Cracking the RSA algorithm is theoretically possible, but not practically,}\\
              \footnotesize{as it would take thousands of years to do so.}\\
              difference of Turing Machine Performance:\\
              \pic{220619-5}\\
              \footnotesize{\r{Difference: 1 step of Multiband == \(O(t(n))\)}}\\
              \footnotesize{it is the worst case, the 4row machine takes 1 full iteration, just to simulate}\\
              \footnotesize{1 change of the multiband machine.}\\
              \footnotesize{\r{\(\text{Multiband: } O(n) \to \text{ Multirow: } O(n^2)\)}}\\
              }\\
              \hline
              \mc{\r{Simulation of a Nondeterministic Turing Machine}\\
                \begin{tabular}{cc}
                  \mc{
                  -- N possibilities.\\
                  -- Every step gives \(\leq N\) possibilities\\
                  -- Amount of steps: t(n)\\
                  -- Worst case: \(N^{t(n)} = 2^{t(n) * log_2 N}\)\\
                  \, \,\, \(2^{O*t(n)}\)\\
                  }&
                  \mc{\pic{220619-6}}\\
                  \end{tabular}
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{Difference in Hardware}\\
              \blu{Difference between deterministic Hardware}\\
              \begin{tabular}{cc}
                \mc{\footnotesize{the difference between deterministic}\\
                \footnotesize{TMs is never big. It stays polynomial!}\\
                \footnotesize{max change: \(O(t_1(n) = O(t_2(n)^k)), k \geq 0\)}
              }&
                \mc{\pic{220619-7}}\\
              \end{tabular}\\
              \blu{Nondeterministic Hardware:}\\
              \footnotesize{Nondeterministic Hardware is always faster!}\\
              \footnotesize{It can be simulated within \(2^{O(t(n))}\) \,  \, \r{Notice the exponential complexity!}}\\
              \footnotesize{The difference between TMs and NTMs is HUGE!}\\
              }\\
              \hline
              \mc{\r{P and NP Problems}\\
              \blu{P is the quantity of problems that can be solved within}\\
              \blu{polynomial time by a deterministic TM}\\
              \gre{NP is the quantity of problems that can be solved within}\\
              \gre{polynomial time by a nondeterministic TM}\\
              \footnotesize{\r{For NP there is always a deterministic TM that can verify the solution!!}}\\
              \footnotesize{\r{NP is a bigger quantity than P!!}}\\
              }\\
              \hline
              \mc{\r{Polynomial and Exponential Problems}\\
              \pic{220619-8}\\
              }\\
              \hline
              \mc{\r{Verificiation of Problems}\\
              \footnotesize{Luckily the simple verification of a problem can always be done in }\\
              \footnotesize{polynomial time by a regular deterministic TM}\\
              \pic{220619-9}\\
              }\\
              \hline
              \mc{\r{An Example for a verifier}\\
              \pic{220619-10}\\
              }\\
              \hline
              \mc{\r{k-Vertex-Coloring}\\
              \footnotesize{The idea of the vertex-coloring problem is that you have k colors and a graph G}\\
              \footnotesize{for every node, each neighbor should have a different color}\\
              \footnotesize{The problem: is it possible for the graph G? -> NP Problem!}\\
              \footnotesize{This problem can be converted to another problem, for example to the timetable problem:}\\
              \begin{tabular}{cc}
                \mc{\footnotesize{Each node is a module}\\
                  \footnotesize{Each color is a time slot}\\
                  \footnotesize{Each edge is a registration}\\
                \footnotesize{The timetable should never overlap}\\
                \footnotesize{k timeslots per week}\\
                }&
                \mc{\pic{220619-11}}\\
              \end{tabular}
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{Polynomial Reduction}\\
              \footnotesize{As the example above has already shown, we can convert problems.}\\
              \footnotesize{Just like with regular reduction, we have converted an easier problem}\\
              \footnotesize{to a more complex one that we already have a verifier for.}\\
              \pic{220619-12}
              }\\
              \hline
              \mc{\r{Hampath}\\
              \footnotesize{Sadly, not every problem is straight forward to convert, some require}\\
              \footnotesize{a bit of ingenuity.}\\
              \footnotesize{Reduction Hampath into a quizz:}\\
              \pic{220619-13}\\
              }\\
              \hline
              \mc{\r{P and NP}\\
              \pic{220619-14}\\
              \footnotesize{Is P and NP the same? If so this would have major consequences!}\\
              \footnotesize{Our cryptography would not be secure anymore! Problem is we can't be sure}\\
              \footnotesize{about whether or not this is the case, P might be different to NP, perhaps not}\\
              \footnotesize{We might find an algorithm to solve sudoku in polynomial time, or might not.}\\
              }\\
              \hline
              \mc{\r{SAT}\\
              \blu{SAT is a Logical formula that needs to be fulfilled.}\\
              \gre{Also called Boolean satifiability problem}\\
              }\\
              \hline
              \mc{\r{Fill-in Puzzle}\\
              \footnotesize{A polynomial fill-in puzzle is a n x m table into which we }\\
              \footnotesize{enter symbols of an alphabet \(\Sigma\), so that it coheres}\\
              \footnotesize{to logical rules, which can be evaluated in polynomial time. }\\
              \pic{220619-15}\\
              Every fill-in puzzle can be reduced to SAT.\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{Computation History}\\
              \pic{220619-16}\\
              }\\
              \hline
              \mc{\r{Cook Levins Law}\\
              1. SAT is NP-Complete\\
              2. if \(A \in NP\)\\
              \, \,\, \footnotesize{There exists an NTM for A that computes in polynomial time \(O(t(n))\)}\\
              \, \,\, \footnotesize{Therefore A can be reduced to SAT in polynomial time}\\
              3. \(A \leq_P SAT\)\\\\
              \footnotesize{The way to do this, is by turning A into a fill-in puzzle}\\
              \footnotesize{From there on it is easy, as we already know that fill-in puzzles}\\
              \footnotesize{can be reduced to SAT!}\\
              \r{Reduction to polynomial fill-in puzzle}\\
              \pic{220619-17}\\
              \(O(t(n)^2) \) -> Amount of symbols and states * bandlength
              }\\
              \hline
              \mc{\r{3SAT to k-Clique}\\
              \pic{220619-19}\\
              \footnotesize{Connect each node to every node that doesn't contradict itself (NOT \(x1\) to \(\overline x1\))}\\
              \footnotesize{Only connect nodes from a different clause, (the conjunctions from 3SAT)}\\
              \footnotesize{If you can then make a triangle with a node from each clause,}\\
              \footnotesize{You have a TRUE from 3SAT. :)}\\
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{3SAT to SUBSET-SUM}\\
              \pic{220619-20}\\
              }\\
              \hline
              \mc{\r{Karp-Catalog}\\
              \footnotesize{A catalog of NP-complete problems}\\
              \footnotesize{The arrow denote the reducability. e.g. 3SAT to SUBSET-SUM}\\
              \pic{220619-21}
              }\\
              \hline
              \mc{\r{Turing Machine vs PC}\\
              \begin{tabular}{cc}
                \mc{Turing Machine\\
                \footnotesize{States Q}\\
                \footnotesize{Practically infinite memory -> Band}\\
                \footnotesize{Read-Write Head}\\
                \footnotesize{Stop -> \(q_{accept}\) or \(q_{reject}\)}\\
                \footnotesize{\r{TM made for specific problem}}\\
                }&
                \mc{Regular PC\\
                \footnotesize{Sates of CPU: Bits etc}\\
                \footnotesize{virtual Memory (practically infinite)}\\
                \footnotesize{Adress Register, Program Counter}\\
                \footnotesize{EXIT\_SUCCESS, EXIT\_FAILURE}\\
                \footnotesize{\r{runs ANY program}}\\
                }\\
              \end{tabular}
              }\\
              \hline
              \mc{\r{The universal Turing Machine}\\
              \footnotesize{Alan Turing made a Turing Machine that can simulate another TM!}\\
              \footnotesize{These are the things needed for the TM:}\\
              -- Band for the transition function from TM to TM\\
              \, \,\, \(\delta : Q \times \Gamma \to Q \times \Gamma \times \{L,R\}\)\\
              -- Band for the current state\\
              -- Working Band\\
              }\\
              \hline
              \mc{\r{Things that are missing on a TM}\\
              -- Persistent Memory (Storage)\\
              -- Input with keyboard/mouse\\
              -- Input/Output (Monitor etc)\\
              \footnotesize{\r{None of these additions change anything. }}\\
              \footnotesize{\r{ are just things we added for quality of life}}\\
              \footnotesize{\r{aka, all of these changes can be implemented on a TM,}}\\
              \footnotesize{\r{ any issues as well! Just slow....}}\\
              }\\
              \hline
              \mc{\r{Comparison of Machines}\\
                \blu{If Machine 1 can simulate Machine 2}\\
                \blu{Then Machine 1 is "more powerful" than Machine 2}\\
                \gre{\(M_2 \leq_s M_1\) M1 simulates M2}\\
                \footnotesize{\r{Unfortunately, the term is misleading, a PC is faster than a TM}}\\
                \footnotesize{\r{But according to this an 8bit CPU and a TM are the same....}}\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{\r{Game of Life}\\
              \pic{220619-22}
              }\\
              \hline
              \mc{\r{Turing Complete}\\
              \blu{Do we lose any capabilities of a TM with programming languages?}\\
              \blu{If no, then said language is Turing complete!}\\
              \gre{\(TM \leq_s \text{Programming lanugage}\)}\\
              \footnotesize{Or a programming language A is Turing Complete, if a projection:}\\
              \gre{\(c : A \to \Sigma^*\)}\\
              \footnotesize{exists, where c(w) is a program of a univeral Turing machine.}\\
              \footnotesize{examples of Turing complete languages: C, C++, javascript (Browser LOL), etc.}\\
              }\\
              \hline
              \mc{\r{Base elements of a Programming language}\\
              \blu{Both turing complete and not turing complete offer this:}\\
              \begin{tabular}{cc}
                \hspace{-0.1in}
                \mc{
              -- Constants c: \(\mathbb{N}_0\) \(0 \to \infty\)\\
              -- Variables \(x_1 ,x_{..}\): \(\mathbb{N}_0\)\\
              -- Assigment: \(x_i\) := c\\
              -- Addition: \(x_i\) := \(x_j + c\)\\
              -- Subtraction: \(x_i\) := \(x_j - c\)\\
              \, \,\,\footnotesize{Note is \(c \ge x_j\) then \(x_i = 0\)}\\
              }&
              \mc{!Not Included!:\\
              -- NO addition of variables: \(x_i + x_j\)\\
              -- NO subtraction of variables: \(x_i - x_j\)\\
              -- NO division or multiplication\\
              }\\
              \end{tabular}
              }\\
              \hline
              \mc{\r{Non-Turing Complete Languages}\\
              \blu{These types of languages ALWAYS halt! No halting problem!}\\
              \gre{LOOP}: \r{not} turing complete\\
              \pic{220619-23}\\
              \footnotesize{We do not have conditional loops, only n says how many times we loop}\\
              \footnotesize{This means we will ALWAYS halt, on n. This can be proven by induction, n - 1!}\\
              }\\
              \hline
              \mc{\r{While and GOTO}\\
              \pic{220619-24}\\
              \pic{220619-25}\\
              }\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
    \pagebreak
    \begin{table}[ht!]
        \begin{normalsize}
          \begin{tabular}{ccc}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{
              \pic{220619-26}\\
              }\\
              \hline
            \end{tabular}
            \hspace{-0.1in}
            \begin{tabular}[t]{|@{\hskip1pt}p{10.45cm}|}
              \hline
              \mc{}\\
              \hline
            \end{tabular}
          \end{tabular}
          \hfill
        \end{normalsize}
    \end{table}
\end{document}
